<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>User Reference</TITLE>
<LINK rel="Contents" href="index.html">
<LINK rel="Copyright" href="license.html">
<LINK rel="Start" href="index.html">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

Go to the <a href="developer.html">next</a>, <a
href="analysis-tutorial.html">previous</a>, or <a href="index.html">main</a>
section.
<hr>

<h1>User Reference</h1>

<p>Here, we document the features exposed to the user by the MIT
Photonic-Bands package.  We do not document the Scheme language or the
functions provided by libctl (see also the <a
href="http://ab-initio.mit.edu/libctl/doc/user-ref.html">user
reference</a> section of the <a
href="http://ab-initio.mit.edu/libctl/doc/">libctl manual</a>).

<h2><a name="input-vars">Input Variables</a></h2>

<p>These are global variables that you can set to control various
parameters of the Photonic-Bands computation.  They are also listed
(along with their current values) by the <code>(help)</code> command.
In brackets after each variable is the type of value that it should
hold.  (The classes, complex datatypes like
<code>geometric-object</code>, are described in a later subsection.
The basic datatypes, like <code>integer</code>, <code>boolean</code>,
and <code>vector3</code>, are defined by libctl.)

<dl>

<dt><code>geometry</code> [list of <code>geometric-object</code> class]
<dd>Specifies the geometric objects making up the structure being
simulated.  When objects overlap, later objects in the list take
precedence.  Defaults to no objects (empty list).

<p><dt><code>default-material</code> [<code>material-type</code> class]
<dd>Holds the default material that is used for points not in any
object of the geometry list.  Defaults to air (epsilon of 1).  See
also <code>epsilon-input-file</code>, below.

<p><dt><code>ensure-periodicity</code> [<code>boolean</code>]
<dd>If true (the default), then geometric objects are treated as if
they were shifted by all possible lattice vectors; i.e. they are made
periodic in the lattice.

<p><dt><code>geometry-lattice</code> [<code>lattice</code> class]
<dd>Specifies the lattice vectors of the periodic structure.  The unit
lattice vectors form the basis for all other 3-vectors in the
geometry, and their lengths determine the size of the primitive cell.
Defaults to the orthogonal x-y-z vectors of unit length (i.e. a
square/cubic lattice).

<p><dt><code>grid-size</code> [<code>vector3</code>]
<dd>Determines the size of the discrete computational grid along each
of the lattice directions.  Defaults to 16x16x16.  If the third grid
dimension is 1, the computation is two-dimensional.  (That is, the
dielectric function is two-dimensional; it is still, in principle, a
three dimensional system, and the k-point vectors can be
three-dimensional.)  Note that the computational grid is centered on
the origin of the coordinate system.

<p><dt><code>mesh-size</code> [<code>integer</code>]
<dd>At each grid point, the dielectric constant is averaged over a
"mesh" of points to find an effective dielectric tensor.  This mesh is
a grid with <code>mesh-size</code> points on a side.  Defaults to 3.
Increasing <code>mesh-size</code> makes the the average dielectric
constant sensitive to smaller structural variations without increasing
the grid size, but also means that computing the dielectric function
will take longer.  (Using a <code>mesh-size</code> of <code>1</code>
turns <em>off</em> dielectric function averaging and the creation of
an effective dielectric tensor at interfaces.  Be sure you know what
you're doing before you worsen convergence in this way.)


<p><dt><code>dimensions</code> [<code>integer</code>]
<dd>Explicitly specifies the dimensionality of the simulation; if the
value is less than 3, the sizes of the extra dimensions in
<code>grid-size</code> are ignored (assumed to be one).  Usually, it
is easier to set the dimensions through <code>grid-size</code>, as
discussed above.  Defaults to 3.

<p><dt><code><a name="k-points">k-points</a></code> [list of
<code>vector3</code>]
<dd>List of Bloch wavevectors to compute the bands at, expressed in
the basis of the reciprocal lattice vectors (<em>not</em> the
unit-normalized reciprocal lattice vectors).  The reciprocal lattice
vectors are defined as follows: Given the lattice vectors
<code>R<sub>i</sub></code>, the reciprocal lattice vector
<code>G<sub>j</sub></code> satisfies <code>R<sub>i</sub> *
G<sub>j</sub> = 2*Pi*delta<sub>i,j</sub></code>, where
<code>delta<sub>i,j</sub></code> is the Kronecker delta (1 for <code>i
= j</code> and 0 otherwise). <code>k-points</code> defaults to none
(empty list).

<p><dt><code>num-bands</code> [<code>integer</code>]
<dd>Number of bands (eigenvectors) to compute at each k
point. Defaults to 1.

<p><dt><code>target-freq</code> [<code>number</code>]

<dd>If zero, the lowest-frequency <code>num-bands</code> states are
solved for at each k point (ordinary eigenproblem).  If non-zero,
solve for the <code>num-bands</code> states whose frequencies are have
the smallest absolute difference with <code>target-freq</code>
(special, "targeted" eigenproblem).  Beware that the targeted solver
converges more slowly than the ordinary eigensolver and may require a
lower <code>tolerance</code> to get reliable results.  Defaults to 0.

<p><dt><code>tolerance</code> [<code>number</code>]
<dd>Specifies when convergence of the eigensolver is judged to have
been reached (when the eigenvalues have a fractional change less than
<code>tolerance</code> between iterations).  Defaults to 1.0e-4.

<p><dt><code>filename-prefix</code> [<code>string</code>]
<dd>A string prepended to all output filenames.  Defaults to
<code>""</code> (no prefix).

<p><dt><code>epsilon-input-file</code> [<code>string</code>]
<dd>If this string is not <code>""</code> (the default), then it
should be the name of an HDF5 file whose first/only dataset defines a
dielectric function (over some discrete grid).  This dielectric
function is then used in place of <code>default-material</code>
(<i>i.e.</i> where there are no <code>geometry</code> objects).  The
grid of the epsilon file dataset need not match
<code>grid-size</code>; it is scaled and/or linearly interpolated as
needed.  The lattice vectors for the epsilon file are assumed to be
the same as <code>geometry-lattice</code>.  [ Note that, even if the
grid sizes match and there are no geometric objects, the dielectric
function used by MPB will not be exactly the dielectric function of
the epsilon file, unless you also set <code>mesh-size</code> to
<code>1</code> (see above). ]

<p><dt><code>simple-preconditioner?</code> [<code>boolean</code>]
<dd>Whether or not to use a simplified preconditioner; defaults to
<code>false</code> (this is fastest most of the time).  (Turning this
on increases the number of iterations, but decreases the time for each
iteration.)

<p><dt><code>deterministic?</code> [<code>boolean</code>]
<dd>Since the fields are initialized to random values at the start of
each run, there are normally slight differences in the number of
iterations, etcetera, between runs.  Setting
<code>deterministic?</code> to <code>true</code> makes things
deterministic (the default is <code>false</code>).

<p><dt><code>eigensolver-flags</code> [<code>integer</code>]
<dd>This variable is undocumented and reserved for use by Jedi Masters only.

</dl>

<h2><a name="predef-vars">Predefined Variables</a></h2>

<p>Variables predefined for your convenience and amusement.

<dl>

<dt><code>air</code>, <code>vacuum</code> [<code>material-type</code> class]
<dd>Two aliases for a predefined material type with a dielectric
constant of 1.

<p><dt><code>infinity</code> [<code>number</code>]
<dd>A big number (1.0e20) to use for "infinite" dimensions of objects.

</dl>

<h2><a name="output-vars">Output Variables</a></h2>

<p>Global variables whose values are set upon completion of the
eigensolver.

<dl>

<dt><code>freqs</code> [list of <code>number</code>]
<dd>A list of the frequencies of each band computed for the last k
point.  Guaranteed to be sorted in increasing order.  The frequency of
band <code>b</code> can be retrieved via <code>(list-ref freqs (- b
1))</code>.

<p><dt><code>iterations</code> [<code>integer</code>]
<dd>The number of iterations required for convergence of the last k point.

<p><dt><code>z-parity</code> [list of <code>number</code>]
<dd>A list of the "z-parities" of each band computed for the last k
point (in the same order as <code>freqs</code>).  The z-parity of a
state is defined as the expectation value of the mirror-flip operation
through z=0.  For true even and odd eigenstates (see
<code>run-even</code> and <code>run-odd</code>), this will be +1 and
-1, respectively; for other states it will be something in between.
This is useful when you have a nearly symmetric structure, such as a
waveguide with a substrate underneath, and you want to tell which
bands are even-like (z-parity &gt; 0) and odd-like (z-parity &lt; 0).
The value of this variable is included in the output as a
comma-delimited line prefixed with "<code>zparity:</code>".

</dl>

<p>Yet more global variables are set by the <code>run</code> function
(and its variants), for use after <code>run</code> completes or by a
band function (which is called for each band during the execution of
<code>run</code>.

<dl>

<dt><code>current-k</code> [<code>vector3</code>]
<dd>The k point (from the <code>k-points</code> list) most recently
 solved.

<p><dt><code>gap-list</code> [list of <code>(<i>percent freq-min freq-max</i>)</code> lists]
<dd>This is a list of the gaps found by the eigensolver, and is set by
the <code>run</code> functions when two or more k-points are solved.
(It is the empty list if no gaps are found.)

<p><dt><code>band-range-data</code> [list of <code>((<i>min . kpoint</i>) . (<i>max . kpoint</i>))</code> pairs (of pairs)]
<dd>For each band, this list contains the minimum and maximum
frequencies of the band, and the associated k points where the extrema
are achieved.  Note that the bands are defined by sorting the
frequencies in increasing order, so this can be confused if two bands
cross.

</dl>

<h2><a name="classes">Classes</a></h2>

<p>Classes are complex datatypes with various "properties" which may
have default values.  Classes can be "subclasses" of other classes;
subclasses inherit all the properties of their superclass, and can be
used any place the superclass is expected.  An object of a class is
constructed with:

<pre>
(make <i>class</i> (<i>prop1 val1</i>) (<i>prop2 val2</i>) ...)
</pre>

<p>See also the <a href="http://ab-initio.mit.edu/libctl/doc/">libctl
manual</a>.

<p>MIT Photonic-Bands defines several types of classes, the most
numerous of which are the various geometric object classes.  You can
also get a list of the available classes, along with their property
types and default values, at runtime with the <code>(help)</code>
command.

<h3>lattice</h3>

<p>The lattice class is normally used only for the
<code>geometry-lattice</code> variable, and specifies the three
lattice directions of the crystal and the lengths of the corresponding
lattice vectors.

<dl>

<dt><code>lattice</code>
<dd>Properties:
<dl>
<dt><code>basis1</code>, <code>basis2</code>, <code>basis3</code> [<code>vector3</code>]
<dd>The three lattice directions of the crystal, specified in the
cartesian basis.  The lengths of these vectors are ignored--only their
directions matter.  The corresponding unit vectors are used as the
basis for all other 3-vectors in the ctl file.  They default to the x,
y, and z directions, respectively.
<dt><code>size</code> [<code>vector3</code>]
<dd>The size of the lattice (i.e. the length of the lattice vectors,
in which the crystal is periodic) along the three basis directions.
(Alternatively, you can think of this as the vector between opposite
corners of the primitive cell, specified in the lattice basis.)
Defaults to unit lengths.
</dl>

</dl>

<h3>material-type</h3>

<p>This class is used to specify the materials that geometric objects
are made of.  Currently, there are two subclasses,
<code>dielectric</code> and <code>dielectric-anisotropic</code>, and
in the future there may be others.

<dl>

<dt><code>dielectric</code>
<dd>A uniform, isotropic, linear dielectric material, with one property:
<dl>
<dt><code>epsilon</code> [<code>number</code>]
<dd>The dielectric constant (must be positive).  No default value.
</dl>

<p><dt><code>dielectric-anisotropic</code>
<dd>A uniform, possibly anisotropic, linear dielectric material.  For
this material type, you specify the (real, symmetric) dielectric
tensor (relative to the cartesian xyz axes):
<pre>
             a  u  v
epsilon =  ( u  b  w )
             v  w  c
</pre>
<p>This allows your dielectric to have different dielectric constants
for fields polarized in different directions.  The components of the
tensor are specified via two properties:
<dl>
<dt><code>epsilon-diag</code> [<code>vector3</code>]
<dd>The diagonal elements (a b c) of the dielectric tensor.  No default value.
<dt><code>epsilon-offdiag</code> [<code>vector3</code>]
<dd>The off-diagonal elements (u v w) of the dielectric tensor.  Defaults to
zero.
</dl>
<p>For example, a material with a dielectric constant of 3.0 for TE
fields (polarized in the xy plane) and 5.0 for TM fields (polarized in
the z direction) would be specified via <code>(make
(dielectric-anisotropic (epsilon-diag 3 3 5)))</code>.

</dl>

<h3>geometric-object</h3>

<p>This class, and its descendants, are used to specify the solid
geometric objects that form the dielectric structure being simulated.
The base class is:

<dl>

<dt><code>geometric-object</code>
<dd>Properties:
<dl>
<dt><code>material</code> [<code>material-type</code> class]
<dd>The material that the object is made of (usually some sort of
dielectric).  No default value (must be specified).
<dt><code>center</code> [<code>vector3</code>]
<dd>Center point of the object.  No default value.
</dl>

</dl>

<p>One normally does not create objects of type
<code>geometric-object</code> directly, however; instead, you use one
of the following subclasses.  Recall that subclasses inherit the
properties of their superclass, so these subclasses automatically have
the <code>material</code> and <code>center</code> properties (which
must be specified, since they have no default values).

<p>Recall that all 3-vectors, including the center of an object, its
axes, and so on, are specified in the basis of the unit-normalized
lattice vectors.  Note also that 3-vector properties can be specified
by either <code>(<i>property</i> (vector3 <i>x y z</i>))</code> or,
equivalently, <code>(<i>property</i> <i>x y z</i>)</code>.

<p>In a two-dimensional calculation, only the intersections of the
objects with the x-y plane are considered.

<dl>

<dt><code>sphere</code>
<dd>A sphere.  Properties:
<dl>
<dt><code>radius</code> [<code>number</code>]
<dd>Radius of the sphere.  No default value.
</dl>

<p><dt><code>cylinder</code>
<dd>A cylinder, with circular cross-section and finite height.  Properties:
<dl>
<dt><code>radius</code> [<code>number</code>]
<dd>Radius of the cylinder's cross-section.  No default value.
<dt><code>height</code> [<code>number</code>]
<dd>Length of the cylinder along its axis.  No default value.
<dt><code>axis</code> [<code>vector3</code>]
<dd>Direction of the cylinder's axis; the length of this vector is
ignored.  Defaults to point parallel to the z axis.
</dl>

<p><dt><code>block</code>
<dd>A parallelepiped (i.e., a brick, possibly with non-orthogonal
axes). Properties:
<dl>
<dt><code>size</code> [<code>vector3</code>]
<dd>The lengths of the block edges along each of its three axes.  Not
really a 3-vector (at least, not in the lattice basis), but it has
three components, each of which should be nonzero.  No default value.
<dt><code>e1</code>, <code>e2</code>, <code>e3</code> [<code>vector3</code>]
<dd>The directions of the axes of the block; the lengths of these
vectors are ignored.  Must be linearly-independent.  They default to
the three lattice directions.
</dl>

<p><dt><code>ellipsoid</code>
<dd>An ellipsoid.  This is actually a subclass of <code>block</code>,
and inherits all the same properties, but defines an ellipsoid
inscribed inside the block.

</dl>

<p>Here are some examples of geometric objects created using the above
classes, assuming that the lattice directions (the basis) are just the
ordinary unit axes, and <code>m</code> is some material we have
defined:

<pre>
; A cylinder of infinite radius and height 0.25 pointing along the x axis,
; centered at the origin:
(make cylinder (center 0 0 0) (material m) 
               (radius infinity) (height 0.25) (axis 1 0 0))


; An ellipsoid with its long axis pointing along (1,1,1), centered on
; the origin (the other two axes are orthogonal and have equal
; semi-axis lengths):
(make ellipsoid (center 0 0 0) (material m)
                (size 0.8 0.2 0.2)
		(e1 1 1 1)
		(e2 0 1 -1)
		(e3 -2 1 1))

; A unit cube of material m with a spherical air hole of radius 0.2 at
; its center, the whole thing centered at (1,2,3):
(set! geometry (list
		(make block (center 1 2 3) (material m) (size 1 1 1))
		(make sphere (center 1 2 3) (material air) (radius 0.2))))
</pre>

<h2><a name="functions">Functions</a></h2>

<p>Here, we describe the functions that are defined by the
Photonic-Bands package.  There are many types of functions defined,
ranging from utility functions for duplicating geometric objects to
run functions that start the computation.

<p>See also the <a
href="http://ab-initio.mit.edu/libctl/doc/user-ref.html">refrence
section</a> of the libctl manual, which describes a number of useful
functions defined by libctl.

<h3>Geometry utilities</h3>

<p>Some utility functions are provided to help you manipulate
geometric objects:

<dl>

<dt><code>(shift-geometric-object <i>obj shift-vector</i>)</code>
<dd>Translate <code>obj</code> by the 3-vector <code>shift-vector</code>.

<p><dt><code>(geometric-object-duplicates <i>shift-vector min-multiple max-multiple obj</i>)</code>
<dd>Return a list of duplicates of <code>obj</code>, shifted by
various multiples of <code>shift-vector</code> (from
<code>min-multiple</code> to <code>max-multiple</code>, inclusive, in
steps of 1).

<p><dt><code>(geometric-objects-duplicates <i>shift-vector min-multiple max-multiple obj-list</i>)</code>
<dd>Same as <code>geometric-object-duplicates</code>, except operates
on a list of objects, <code>obj-list</code>.  If <i>A</i> appears
before <i>B</i> in the input list, then all the duplicates of <i>A</i>
appear before all the duplicates of <i>B</i> in the output list.

<p><dt><code>(geometric-objects-lattice-duplicates <i>obj-list [ ux uy uz ]</i>)</code>
<dd>Duplicates the objects in <code>obj-list</code> by multiples of
the lattice basis vectors, making all possible shifts of the
"primitive cell" (see below) that fit inside the lattice cell.  (This
is useful for supercell calculations; see the <a
href="user-tutorial.html">tutorial</a>.)  The primitive cell to
duplicate is <code>ux</code> by <code>uy</code> by <code>uz</code>, in
units of the basis vectors.  These three parameters are optional; any
that you do not specify are assumed to be <code>1</code>.

<p><dt><code>(point-in-object? <i>point obj</i>)</code>
<dd>Returns whether or not the given 3-vector <code>point</code> is
inside the geometric object <code>obj</code>.

<p><dt><code>(point-in-periodic-object? <i>point obj</i>)</code>
<dd>As <code>point-in-object?</code>, but also checks translations of
the given object by the lattice vectors.

<p><dt><code>(display-geometric-object-info <i>indent-by obj</i>)</code>
<dd>Outputs some information about the given <code>obj</code>,
indented by <code>indent-by</code> spaces.

</dl>

<h3><a name="coordconvert">Coordinate conversion functions</a></h3>

<p>The following functions allow you to easily convert back and forth
between the lattice, cartesian, and reciprocal bases.  (See also the
<a href="user-tutorial.html#units">note on units</a> in the tutorial.)

<dl>

<dt><code>(lattice->cartesian <i>x</i>)</code>, <code>(cartesian->lattice <i>x</i>)</code>
<dd>Convert <code><i>x</i></code> between the lattice basis (the basis
of the unit vectors in the lattice directions) and the ordinary
cartesian basis, where <code><i>x</i></code> is either a
<code>vector3</code> or a <code>matrix3x3</code>, returning the
transformed vector/matrix.  In the case of a matrix argument, the
matrix is treated as an operator on vectors in the given basis, and is
transformed into the same operator on vectors in the new basis.

<p><dt><code>(reciprocal->cartesian <i>x</i>)</code>, <code>(cartesian->reciprocal <i>x</i>)</code>
<dd>Like the above, except that they convert to/from reciprocal space
(the basis of the reciprocal lattice vectors).  Also, the cartesian
vectors output/input are in units of 2 Pi.

<p><dt><code>(reciprocal->lattice <i>x</i>)</code>, <code>(lattice->reciprocal <i>x</i>)</code>
<dd>Convert between the reciprocal and lattice bases, where the
conversion again leaves out the factor of 2 Pi (i.e. the lattice-basis
vectors are assumed to be in units of 2 Pi).

</dl>

<p>Also, a couple of rotation functions are defined, for convenience,
so that you don't have to explicitely convert to cartesian coordinates
in order to use libctl's <code>rotate-vector3</code> function (see the
<a href="http://ab-initio.mit.edu/libctl/doc/user-ref.html">libctl
reference</a>):

<dl>

<dt><code>(rotate-lattice-vector3 <i>axis theta v</i>)</code>, <code>(rotate-reciprocal-vector3 <i>axis theta v</i>)</code>
<dt>Like <code>rotate-vector3</code> , except that
<code><i>axis</i></code> and <code><i>v</i></code> are specified in
the lattice/reciprocal bases.

</dl>

<h3>Run functions</h3>

<p>These are functions to help you run and control the simulation.
The ones you will most commonly use are the <code>run</code> function
and its variants.  The syntax of these functions, and one lower-level
function, is:

<dl>

<dt><code>(run <i>band-func ...</i>)</code>
<dd>This runs the simulation described by the input parameters (see
above), with no constraints on the polarization of the solution.  That
is, it reads the input parameters, initializes the simulation, and
solves for the requested eigenstates of each k-point.  The dielectric
function is outputted to "<code>epsilon.h5</code>" before any
eigenstates are computed.  <code>run</code> takes as arguments zero or
more "band functions" <code>band-func</code>.  A band function should
be a function of one integer parameter, the band index, so that
<code>(band-func which-band)</code> performs some operation on the
band <code>which-band</code> (e.g. outputting fields).  After every k
point, each band function is called for the indices of all the bands
that were computed.

<p><dt><code>(run-te <i>band-func ...</i>), (run-tm <i>band-func ...</i>)</code>
<dd>These are the same as the <code>run</code> function except that
they constrain their solutions to be TE- and TM-polarized,
respectively, in two dimensions.  The TE and TM polarizations are
defined has having electric and magnetic fields in the xy plane,
respectively.  Equivalently, the H/E field of TE/TM light has only a z
component (making it easier to visualize).

<p>For a three-dimensional structure (<code>grid-size</code>) or when
a k point has a nonzero z component, the eigenstates are no longer
completely polarized, and these functions behave identically to
<code>run</code>.  (2d systems oriented in the yz or xz directions
don't work; you have to orient your coordinates to be in the xy
plane.)

<p><dt><code>(run-even <i>band-func ...</i>), (run-odd <i>band-func ...</i>)</code>
<dd>These are the same as the <code>run</code> function except that
they constrain their solutions to have even and odd symmetry with
respect to the z=0 plane.  You should use these functions
<em>only</em> for structures that are symmetric through the z=0 mirror
plane, where the third basis vector is in the z direction (0,0,1), and
when the k vectors are in the xy plane.  Under these conditions, the
eigenmodes always have either even or odd symmetry.  The even/odd
distinction is strongly analogous to TE/TM, respectively, and is
equivalent in 2d; it is useful for structures such as waveguides and
photonic-crystal slabs.  (For example, see the paper by S. G. Johnson
<i>et al.</i>, "Guided modes in photonic crystal slabs," <i>PRB</i>
<b>60</b>, 5751, August 1999.)

<p><dt><code>(run-polarization <i>p reset-fields band-func ...</i>)</code>
<dd>Like the <code>run</code> function, except that it takes two extra
parameters, a polarization <code>p</code> and a boolean
(<code>true</code>/<code>false</code>) value
<code>reset-fields</code>.  <code>p</code> specifies a polarization
constraint, and should be one of the predefined variables
<code>NO-POLARIZATION</code>, <code>TE</code>, <code>TM</code>,
<code>EVEN-Z</code>, or <code>ODD-Z</code> (equivalent to
<code>run</code>, <code>run-te</code>, <code>run-tm</code>,
<code>run-even</code>, and <code>run-odd</code>, respectively).  If
<code>reset-fields</code> is <code>false</code>, the fields from any
previous calculation will be reused as the starting point from this
calculation, if possible; otherwise, the fields are reset to random
values.  The ordinary <code>run</code> functions use a default
<code>reset-fields</code> of<code>true</code>.

<p><dt><code>(display-eigensolver-stats)</code>
<dd>Display some statistics on the eigensolver convergence; this function is
useful mainly for MPB developers in tuning the eigensolver.

</dl>

<p>Several band functions for outputting the eigenfields are defined
for your convenience, and are described in the <b>Band output
functions</b> section, below.  You can also define your own band
functions, and for this purpose the functions described in the section
<b>Field manipulation functions</b>, below, are useful.  A band
function takes the form:

<pre>
(define (<i>my-band-func</i> which-band)
  <i>...do stuff here with band index which-band...</i>
)
</pre>

<p>Note that the output variable <code>freqs</code> may be used to
retrieve the frequency of the band (see above).  Also, a global
variable <code>current-k</code> is defined holding the current k-point
vector from the <code>k-points</code> list.

<p>There are also some even lower-level functions that you can call,
although you should not need to do most of the time:

<dl>

<dt><code>(init-params <i>p reset-fields?</i>)</code>

<dd>Read the input variables and initialize the simulation in
preparation for computing the eigenvalues.  The parameters are the
same as the first two parameters of <code>run-polarization</code>.
This function <em>must</em> be called before any of the other
simulation functions below.  (Note, however, that the <code>run</code>
functions all call <code>init-params</code>.)

<p><dt><code>(set-polarization <i>p</i>)</code>
<dd>After calling <code>init-params</code>, you can change the
polarization constraint without resetting the other parameters by
calling this function.  Beware that this does not randomize the fields
(see below); you don't want to try to solve for, say, the TM
eigenstates when the fields are initialized to TE states from a
previous calculation.

<p><dt><code>(randomize-fields)</code>
<dd>Initialize the fields to random values.

<p><dt><code>(solve-kpoint <i>k</i>)</code>
<dd>Solve for the requested eigenstates at the Bloch wavevector
<code>k</code>.

</dl>

<h3>Band output functions</h3>

<p>All of these are functions that, given a band index, output the
corresponding field or some function thereof (in the primitive cell of
the lattice).  They are designed to be passed as band functions to the
<code>run</code> routines, although they can also be called directly.

<dl>

<dt><code>(output-hfield <i>which-band</i>)</code>
<dt><code>(output-hfield-x <i>which-band</i>)</code>
<dt><code>(output-hfield-y <i>which-band</i>)</code>
<dt><code>(output-hfield-z <i>which-band</i>)</code>
<dd>Output the magnetic (H) field for <code>which-band</code>; either
all or one of the components, respectively.

<p><dt><code>(output-dfield <i>which-band</i>)</code>
<p><dt><code>(output-dfield-x <i>which-band</i>)</code>
<p><dt><code>(output-dfield-y <i>which-band</i>)</code>
<p><dt><code>(output-dfield-z <i>which-band</i>)</code>
<dd>Output the electric displacement (D) field for
<code>which-band</code>; either all or one of the components,
respectively.

<p><dt><code>(output-efield <i>which-band</i>)</code>
<p><dt><code>(output-efield-x <i>which-band</i>)</code>
<p><dt><code>(output-efield-y <i>which-band</i>)</code>
<p><dt><code>(output-efield-z <i>which-band</i>)</code>
<dd>Output the electric (E) field for <code>which-band</code>; either
all or one of the components, respectively.

<p><dt><code>(output-hpwr <i>which-band</i>)</code>
<dd>Output the time-averaged magnetic-field energy density (hpwr) for
<code>which-band</code>.

<p><dt><code>(output-dpwr <i>which-band</i>)</code>
<dd>Output the time-averaged electric-field energy density (hpwr) for
<code>which-band</code>.

</dl>

<p>Sometimes, you only want to output certain bands.  For example,
here is a function that, given an band/output function like the ones
above, returns a new output function that only calls the first
function for bands with a large fraction of their energy in an object(s).
(This is useful for picking out defect states in supercell
calculations.)

<dl>

<dt><code>(output-dpwr-in-objects <i>band-func min-energy objects...</i>)</code>

<dd>Given a band function <code>band-func</code>, returns a new band
function that only calls <code>band-func</code> for bands having a
fraction of their electric-field energy greater than
<code>min-energy</code> inside the given objects (zero or more
geometric objects).  Also, for each band, prints the fraction of their
energy in the objects in the following form (suitable for grepping):

<pre>
dpwr:, <i>band-index</i>, <i>frequency</i>, <i>energy-in-objects</i>
</pre>

</dl>

<p><code>output-dpwr-in-objects</code> only takes a single band
function as a parameter, but if you want it to call several band
functions, you can easily combine them into one with the following
routine:

<dl>

<dt><code>(combine-band-functions <i>band-funcs...</i>)</code>
<dd>Given zero or more band functions, returns a new band function
that calls all of them in sequence.  (When passed zero parameters,
returns a band function that does nothing.)

</dl>

<p>It is also often useful to output the fields only at a certain k-point,
to let you look at typical field patterns for a given band while avoiding
gratuitous numbers of output files.  This can be accomplished via:

<dl>

<dt><code>(output-at-kpoint <i>k-point</i> <i>band-funcs...</i>)</code>
<dd>Given zero or more band functions, returns a new band function
that calls all of them in sequence, but only at the specified
<code>k-point</code>.  For other k-points, does nothing.

</dl>

<h4>Outputting multiple periods</h4>

<p>By default, all of these functions output the fields in only a
single unit cell.  However, you can change this by setting the
variable <code>output-copies</code> to <code>(list <i>nx ny
nz</i>)</code> indicating the number of periods to output along each
lattice direction (just as for <code>output-field</code>, below).
All of the above output functions will output the number of periods
indicated by <code>output-copies</code>, and that also includes the
dielectric function that is output automatically by <code>run</code>.

<p>This, of course, doesn't affect any band functions that you write
"manually" using the <code>output-field</code> function below.

<h3>Field manipulation functions</h3>

<p>The Photonic-Bands package provides a number of ways to take the
field of a band and manipulate, process, or output it.  These methods
usually work in two stages.  First, one loads a field into memory
(computing it in position space) by calling one of the
<code>get</code> functions below.  Then, other functions can be called
to transform or manipulate the field.  Currently, only one field
(vector or scalar) can be manipulated at a time.

<p>The available <code>get</code> functions follow.  They should only
be called after the eigensolver has run (or after
<code>init-params</code>, in the case of <code>get-epsilon</code>).
One normally calls them after <code>run</code>, or in one of the band
functions passed to <code>run</code>.

<dl>

<dt><code>(get-hfield <i>which-band</i>)</code>
<dd>Loads the magnetic (H) field for the band <code>which-band</code>.

<p><dt><code>(get-dfield <i>which-band</i>)</code>
<dd>Loads the electric displacement (D) field for the band
<code>which-band</code>.

<p><dt><code>(get-efield <i>which-band</i>)</code>
<dd>Loads the electric (E) field for the band <code>which-band</code>.
(This function actually calls <code>get-dfield</code> followed by
<code>get-efield-from-dfield</code>, below.)

<p><dt><code>(get-epsilon)</code>
<dd>Loads the dielectric function.

</dl>

<p>Once loaded, the field can be transformed into another field or a
scalar field:

<dl>

<dt><code>(get-efield-from-dfield)</code>
<dd>Multiplies by the inverse dielectric tensor to compute the
electric field from the displacement field.  Only works if a D field
has been loaded.

<p><dt><code>(compute-field-energy)</code>
<dd>Given the H or D fields, computes the corresponding energy density
function.  Also prints the fraction of the field in each of its
cartesian components in the following form (suitable for grepping):

<pre>
<i>f</i>-energy-components:, <i>k-index</i>, <i>band-index</i>, <i>x-fraction</i>, <i>y-fraction</i>, <i>z-fraction</i>
</pre>

<p>where <code><i>f</i></code> is either <code>h</code> or <code>d</code>.

</dl>

<p>Given an energy-density function, loaded by
<code>compute-field-energy</code>, various functions can be computed:

<dl>

<dt><code>(compute-energy-in-dielectric <i>min-eps max-eps</i>)</code>
<dd>Returns the fraction of the energy that resides in dielectrics
with epsilon in the range <code>min-eps</code> to
<code>max-eps</code>.

<p><dt><code>(compute-energy-in-objects <i>objects...</i>)</code>
<dd>Returns the fraction of the energy inside zero or more geometric
objects.

</dl>

<p>Finally, we have the following functions to output fields (either
the vector fields, the scalar energy density, or epsilon), with the
option of outputting several periods of the lattice.

<dl>

<dt><code>(output-field <i>[ nx [ ny [ nz ] ] ]</i>)</code>
<dt><code>(output-field-x <i>[ nx [ ny [ nz ] ] ]</i>)</code>
<dt><code>(output-field-y <i>[ nx [ ny [ nz ] ] ]</i>)</code>
<dt><code>(output-field-z <i>[ nx [ ny [ nz ] ] ]</i>)</code>
<dd>Output the currently-loaded field.  The optional (as indicated by
the brackets) parameters <code>nx</code>, <code>ny</code>, and
<code>nz</code> indicate the number of periods to be outputted along
each of the three lattice directions.  Omitted parameters are assumed
to be 1.  For vector fields, <code>output-field</code> outputs all of
the components, while the other variants output only one component.

<p><dt><code>(output-epsilon <i>[ nx [ ny [ nz ] ] ]</i>)</code>
<dd>A shortcut for calling <code>get-epsilon</code> followed by
<code>output-field</code>.

</dl>

<hr>
Go to the <a href="developer.html">next</a>, <a
href="analysis-tutorial.html">previous</a>, or <a href="index.html">main</a>
section.

</BODY>
</HTML>
