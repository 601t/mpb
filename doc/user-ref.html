<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>User Reference</TITLE>
<LINK rel="Contents" href="index.html">
<LINK rel="Copyright" href="license.html">
<LINK rel="Start" href="index.html">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

Go to the <a href="developer.html">next</a>, <a href="analysis-tutorial.html">previous</a>, or <a href="index.html">main</a> section.
<hr>

<h1>User Reference</h1>

<p>Here, we document the features exposed to the user by the MIT
Photonic-Bands package.  We do not document the Scheme language or the
functions provided by libctl (see also the <a
href="http://ab-initio.mit.edu/libctl/doc/user-ref.html">user
reference</a> section of the <a
href="http://ab-initio.mit.edu/libctl/doc/">libctl manual</a>).

<h2><a name="input-vars">Input Variables</a></h2>

<p>These are global variables that you can set to control various
parameters of the Photonic-Bands computation.  They are also listed
(along with their current values) by the <code>(help)</code> command.
In brackets after each variable is the type of value that it should
hold.  (The classes, complex datatypes like
<code>geometric-object</code>, are described in a later subsection.
The basic datatypes, like <code>integer</code>, <code>boolean</code>,
<code>cnumber</code>, and <code>vector3</code>, are defined by libctl.)

<dl>

<dt><code>geometry</code> [list of <code>geometric-object</code> class]
<dd>Specifies the geometric objects making up the structure being
simulated.  When objects overlap, later objects in the list take
precedence.  Defaults to no objects (empty list).

<p><dt><code>default-material</code> [<code>material-type</code> class]
<dd>Holds the default material that is used for points not in any
object of the geometry list.  Defaults to air (epsilon of 1).  See
also <code>epsilon-input-file</code>, below.

<p><dt><code>ensure-periodicity</code> [<code>boolean</code>]
<dd>If true (the default), then geometric objects are treated as if
they were shifted by all possible lattice vectors; i.e. they are made
periodic in the lattice.

<p><dt><code>geometry-lattice</code> [<code>lattice</code> class]
<dd>Specifies the basis vectors and lattice size of the computational
cell (which is centered on the origin of the coordinate system).
These vectors form the basis for all other 3-vectors in the geometry,
and the lattice size determines the size of the primitive cell.  If
any dimension of the lattice size is the special value
<code>no-size</code>, then the dimension of the lattice is reduced
(i.e. it becomes two- or one-dimensional).  (That is, the dielectric
function becomes two-dimensional; it is still, in principle, a three
dimensional system, and the k-point vectors can be three-dimensional.)
Generally, you should make any <code>no-size</code> dimension(s)
perpendicular to the others.  Defaults to the orthogonal x-y-z vectors
of unit length (i.e. a square/cubic lattice).

<p><dt><code>resolution</code> [<code>number</code> or <code>vector3</code>]
<dd>Specifies the computational grid resolution, in pixels per lattice
unit (a lattice unit is one basis vector in a given direction).  If
<code>resolution</code> is a <code>vector3</code>, then specifies a
different resolution for each direction; otherwise the resolution is
uniform.  (The grid size is then the product of the lattice size and
the resolution, rounded up to the next positive integer.)  Defaults to
<code>10</code>.

<p><dt><code>grid-size</code> [<code>vector3</code>]
<dd>Specifies the size of the discrete computational grid along each
of the lattice directions.  <em>Deprecated:</em> the preferred method
is to use the <code>resolution</code> variable, above, in which case
the <code>grid-size</code> defaults to <code>false</code>.  To get the
grid size you should instead use the <code>(get-grid-size)</code>
function.

<p><dt><code>mesh-size</code> [<code>integer</code>]
<dd>At each grid point, the dielectric constant is averaged over a
"mesh" of points to find an effective dielectric tensor.  This mesh is
a grid with <code>mesh-size</code> points on a side.  Defaults to 3.
Increasing <code>mesh-size</code> makes the the average dielectric
constant sensitive to smaller structural variations without increasing
the grid size, but also means that computing the dielectric function
will take longer.  (Using a <code>mesh-size</code> of <code>1</code>
turns <em>off</em> dielectric function averaging and the creation of
an effective dielectric tensor at interfaces.  Be sure you know what
you're doing before you worsen convergence in this way.)

<p><dt><code>dimensions</code> [<code>integer</code>]
<dd>Explicitly specifies the dimensionality of the simulation; if the
value is less than 3, the sizes of the extra dimensions in
<code>grid-size</code> are ignored (assumed to be one).  Defaults to 3.
<em>Deprecated:</em> the preferred method is to set
<code>geometry-lattice</code> to have size </code>no-size</code> in
any unwanted dimensions.

<p><dt><code><a name="k-points">k-points</a></code> [list of
<code>vector3</code>]
<dd>List of Bloch wavevectors to compute the bands at, expressed in
the basis of the reciprocal lattice vectors.  The reciprocal lattice
vectors are defined as follows: Given the lattice vectors
<code>R<sub>i</sub></code> (<em>not</em> the basis vectors), the
reciprocal lattice vector <code>G<sub>j</sub></code> satisfies
<code>R<sub>i</sub> * G<sub>j</sub> = 2*Pi*delta<sub>i,j</sub></code>,
where <code>delta<sub>i,j</sub></code> is the Kronecker delta (1 for
<code>i = j</code> and 0 otherwise).  (<code>R<sub>i</sub></code> for
any <code>no-size</code> dimensions is taken to be the corresponding
basis vector.) Normally, the wavevectors should be in the first
Brillouin zone (<a href="#first-brillouin-zone">see below</a>).
<code>k-points</code> defaults to none (empty list).

<p><dt><code>num-bands</code> [<code>integer</code>]
<dd>Number of bands (eigenvectors) to compute at each k
point. Defaults to 1.

<p><dt><code>target-freq</code> [<code>number</code>]

<dd>If zero, the lowest-frequency <code>num-bands</code> states are
solved for at each k point (ordinary eigenproblem).  If non-zero,
solve for the <code>num-bands</code> states whose frequencies are have
the smallest absolute difference with <code>target-freq</code>
(special, "targeted" eigenproblem).  Beware that the targeted solver
converges more slowly than the ordinary eigensolver and may require a
lower <code>tolerance</code> to get reliable results.  Defaults to 0.

<p><dt><code>tolerance</code> [<code>number</code>]
<dd>Specifies when convergence of the eigensolver is judged to have
been reached (when the eigenvalues have a fractional change less than
<code>tolerance</code> between iterations).  Defaults to 1.0e-7.

<p><dt><code>filename-prefix</code> [<code>string</code>]
<dd>A string prepended to all output filenames.  Defaults to
<code>""</code> (no prefix).

<p><dt><code>epsilon-input-file</code> [<code>string</code>]
<dd>If this string is not <code>""</code> (the default), then it
should be the name of an HDF5 file whose first/only dataset defines a
dielectric function (over some discrete grid).  This dielectric
function is then used in place of <code>default-material</code>
(<i>i.e.</i> where there are no <code>geometry</code> objects).  The
grid of the epsilon file dataset need not match
<code>grid-size</code>; it is scaled and/or linearly interpolated as
needed.  The lattice vectors for the epsilon file are assumed to be
the same as <code>geometry-lattice</code>.  [ Note that, even if the
grid sizes match and there are no geometric objects, the dielectric
function used by MPB will not be exactly the dielectric function of
the epsilon file, unless you also set <code>mesh-size</code> to
<code>1</code> (see above). ]

<p><dt><code>eigensolver-block-size</code> [<code>integer</code>]
<dd>The eigensolver uses a "block" algorithm, which means that it
solves for several bands simultaneously at each k-point.
<code>eigensolver-block-size</code> specifies this number of bands to
solve for at a time; if it is zero or &gt;= <code>num-bands</code>,
then all the bands are solved for at once.  If
<code>eigensolver-block-size</code> is a negative number, -<i>n</i>,
then MPB will try to use nearly-equal block-sizes close to <i>n</i>.
Making the block size a small number can reduce the memory
requirements of MPB, but block sizes &gt; 1 are usually more efficient
(there is typically some optimum size for any given problem).
Defaults to -11 (i.e. solve for around 11 bands at a time).

<p><dt><code>simple-preconditioner?</code> [<code>boolean</code>]
<dd>Whether or not to use a simplified preconditioner; defaults to
<code>false</code> (this is fastest most of the time).  (Turning this
on increases the number of iterations, but decreases the time for each
iteration.)

<p><dt><code>deterministic?</code> [<code>boolean</code>]
<dd>Since the fields are initialized to random values at the start of
each run, there are normally slight differences in the number of
iterations, etcetera, between runs.  Setting
<code>deterministic?</code> to <code>true</code> makes things
deterministic (the default is <code>false</code>).

<p><dt><code>eigensolver-flags</code> [<code>integer</code>]
<dd>This variable is undocumented and reserved for use by Jedi Masters only.

</dl>

<h2><a name="predef-vars">Predefined Variables</a></h2>

<p>Variables predefined for your convenience and amusement.

<dl>

<dt><code>air</code>, <code>vacuum</code> [<code>material-type</code> class]
<dd>Two aliases for a predefined material type with a dielectric
constant of 1.

<dt><code>nothing</code> [<code>material-type</code> class]
<dd>A material that, effectively, punches a hole through other
objects to the background (<code>default-material</code> or
<code>epsilon-input-file</code>).

<p><dt><code>infinity</code> [<code>number</code>]
<dd>A big number (1.0e20) to use for "infinite" dimensions of objects.

</dl>

<h2><a name="output-vars">Output Variables</a></h2>

<p>Global variables whose values are set upon completion of the
eigensolver.

<dl>

<dt><code>freqs</code> [list of <code>number</code>]
<dd>A list of the frequencies of each band computed for the last k
point.  Guaranteed to be sorted in increasing order.  The frequency of
band <code>b</code> can be retrieved via <code>(list-ref freqs (- b
1))</code>.

<p><dt><code>iterations</code> [<code>integer</code>]
<dd>The number of iterations required for convergence of the last k point.

<p><dt><code>parity</code> [<code>string</code>]
<dd>A string describing the current required parity/polarization
(<code>"te"</code>, <code>"zeven"</code>, etcetera, or <code>""</code>
for none), useful for prefixing output lines for grepping.

</dl>

<p>Yet more global variables are set by the <code>run</code> function
(and its variants), for use after <code>run</code> completes or by a
band function (which is called for each band during the execution of
<code>run</code>.

<dl>

<dt><code>current-k</code> [<code>vector3</code>]
<dd>The k point (from the <code>k-points</code> list) most recently
 solved.

<p><dt><code>gap-list</code> [list of <code>(<i>percent freq-min freq-max</i>)</code> lists]
<dd>This is a list of the gaps found by the eigensolver, and is set by
the <code>run</code> functions when two or more k-points are solved.
(It is the empty list if no gaps are found.)

<p><dt><code>band-range-data</code> [list of <code>((<i>min . kpoint</i>) . (<i>max . kpoint</i>))</code> pairs (of pairs)]
<dd>For each band, this list contains the minimum and maximum
frequencies of the band, and the associated k points where the extrema
are achieved.  Note that the bands are defined by sorting the
frequencies in increasing order, so this can be confused if two bands
cross.

</dl>

<h2><a name="classes">Classes</a></h2>

<p>Classes are complex datatypes with various "properties" which may
have default values.  Classes can be "subclasses" of other classes;
subclasses inherit all the properties of their superclass, and can be
used any place the superclass is expected.  An object of a class is
constructed with:

<pre>
(make <i>class</i> (<i>prop1 val1</i>) (<i>prop2 val2</i>) ...)
</pre>

<p>See also the <a href="http://ab-initio.mit.edu/libctl/doc/">libctl
manual</a>.

<p>MIT Photonic-Bands defines several types of classes, the most
numerous of which are the various geometric object classes.  You can
also get a list of the available classes, along with their property
types and default values, at runtime with the <code>(help)</code>
command.

<h3><a name="lattice">lattice</a></h3>

<p>The lattice class is normally used only for the
<code>geometry-lattice</code> variable, and specifies the three
lattice directions of the crystal and the lengths of the corresponding
lattice vectors.

<dl>

<dt><code>lattice</code>
<dd>Properties:
<dl>
<dt><code>basis1</code>, <code>basis2</code>, <code>basis3</code> [<code>vector3</code>]
<dd>The three lattice directions of the crystal, specified in the
cartesian basis.  The lengths of these vectors are ignored--only their
directions matter.  The lengths are determined by the
<code>basis-size</code> property, below.  These vectors are then used
as a basis for all other 3-vectors in the ctl file.  They default to
the x, y, and z directions, respectively.

<dt><code>basis-size</code> [<code>vector3</code>]
<dd>The components of <code>basis-size</code> are the lengths of the
three basis vectors, respectively.  They default ot unit lengths.

<dt><code>size</code> [<code>vector3</code>]
<dd>The size of the lattice (i.e. the length of the lattice vectors
<code>R<sub>i</sub></code>, in which the crystal is periodic) in units
of the basis vectors.  Thus, the actual lengths of the lattice vectors
are given by the components of <code>size</code> multiplied by the
components of <code>basis-size</code>.  (Alternatively, you can think
of <code>size</code> as the vector between opposite corners of the
primitive cell, specified in the lattice basis.)  Defaults to unit
lengths.

<p>If any dimension has the special size <code>no-size</code>, then
the dimensionality of the problem is reduced by one; strictly
speaking, the dielectric function is taken to be uniform along that
dimension.  (In this case, the <code>no-size</code> dimension should
generally be orthogonal to the other dimensions.)
</dl>

</dl>

<h3><a name="material-type">material-type</a></h3>

<p>This class is used to specify the materials that geometric objects
are made of.  Currently, there are three subclasses,
<code>dielectric</code>, <code>dielectric-anisotropic</code>, and
<code>material-function</code>.

<dl>

<dt><code>dielectric</code>
<dd>A uniform, isotropic, linear dielectric material, with one property:
<dl>
<dt><code>epsilon</code> [<code>number</code>]
<dd>The dielectric constant (must be positive).  No default value.  You
can also use <code>(index <i>n</i>)</code> as a synonym for
<code>(epsilon (* <i>n n</i>))</code>.
</dl>

<p><dt><code><a name="dielectric-anisotropic">dielectric-anisotropic</a></code>
<dd>A uniform, possibly anisotropic, linear dielectric material.  For
this material type, you specify the (real-symmetric, or possibly
complex-hermitian) dielectric tensor (relative to the cartesian xyz
axes):
<pre>
             a  u  v
epsilon =  ( u* b  w )
             v* w* c
</pre>
<p>This allows your dielectric to have different dielectric constants
for fields polarized in different directions.  The epsilon tensor must
be positive-definite (have all positive eigenvalues); if it is not,
MPB exits with an error.  (This does <em>not</em> imply that all of
the entries of the epsilon matrix need be positive.)

<p>The components of the tensor are specified via three properties:
<dl>
<dt><code>epsilon-diag</code> [<code>vector3</code>]
<dd>The diagonal elements (a b c) of the dielectric tensor.  No default value.
<dt><code>epsilon-offdiag</code> [<code>cvector3</code>]
<dd>The off-diagonal elements (u v w) of the dielectric tensor.
Defaults to zero.  This is a <code>cvector3</code>, which simply
means that the components may be complex numbers
(e.g. <code>3+0.1i</code>).  If non-zero imaginary parts are
specified, then the dielectric tensor is complex-hermitian.  This is
only supported when MPB is configured with the
<code>--with-hermitian-eps</code> flag.  This is not dissipative (the
eigenvalues of epsilon are real), but rather breaks time-reversal
symmetry, corresponding to a gyrotropic (magneto-optic) material.
Note that <a href="#inv-symmetry">inversion symmetry</a> may not mean
what you expect for complex-hermitian epsilon, so be cautious about
using <code>mpbi</code> in this case.

<dt><code>epsilon-offdiag-imag</code> [<code>vector3</code>]

<dd><em>Deprecated:</em> The imaginary parts of the off-diagonal
elements (u v w) of the dielectric tensor; defaults to zero.  Setting
the imaginary parts directly by specifying complex numbers in
<code>epsilon-offdiag</code> is preferred.
</dl>

<p>For example, a material with a dielectric constant of 3.0 for TE
fields (polarized in the xy plane) and 5.0 for TM fields (polarized in
the z direction) would be specified via <code>(make
(dielectric-anisotropic (epsilon-diag 3 3 5)))</code>.  Please <a
href="#tetm-aniso">be aware</a> that not all 2d anisotropic dielectric
structures will have TE and TM modes, however.

<p><dt><code>material-function</code>
<dd>This material type allows you to specify the material as an
arbitrary function of position.  (For an example of this, see the
<code>bragg-sine.ctl</code> file in the <code>examples/</code>
directory.)  It has one property:
<dl>
<dt><code>material-func</code> [<code>function</code>]
<dd>A function of one argument, the position <code>vector3</code> (in
lattice coordinates), that returns the material at that point.
</dl>
<p>Note that the function you supply can return <em>any</em> material;
wild and crazy users could even return another
<code>material-function</code> object (which would then have its
function invoked in turn).

</dl>

<p>Normally, the dielectric constant is required to be positive (or
positive-definite, for a tensor).  However, MPB does have a somewhat
experimental feature allowing negative dielectrics (e.g. in a plasma).
To use it, call the function <code>(allow-negative-epsilon)</code>
before <code>(run)</code>.  In this case, it will output the (real)
frequency <em>squared</em> in place of the (possibly imaginary)
frequencies.  (Convergence will be somewhat slower because the
eigenoperator is not positive definite.)

<h3><a name="geometric-object">geometric-object</a></h3>

<p>This class, and its descendants, are used to specify the solid
geometric objects that form the dielectric structure being simulated.
The base class is:

<dl>

<dt><code>geometric-object</code>
<dd>Properties:
<dl>
<dt><code>material</code> [<code>material-type</code> class]
<dd>The material that the object is made of (usually some sort of
dielectric).  No default value (must be specified).
<dt><code>center</code> [<code>vector3</code>]
<dd>Center point of the object.  No default value.
</dl>

</dl>

<p>One normally does not create objects of type
<code>geometric-object</code> directly, however; instead, you use one
of the following subclasses.  Recall that subclasses inherit the
properties of their superclass, so these subclasses automatically have
the <code>material</code> and <code>center</code> properties (which
must be specified, since they have no default values).

<p>Recall that all 3-vectors, including the center of an object, its
axes, and so on, are specified in the basis of the normalized lattice
vectors normalized to <code>basis-size</code>.  Note also that
3-vector properties can be specified by either <code>(<i>property</i>
(vector3 <i>x y z</i>))</code> or, equivalently,
<code>(<i>property</i> <i>x y z</i>)</code>.

<p>In a two-dimensional calculation, only the intersections of the
objects with the x-y plane are considered.

<dl>

<dt><code>sphere</code>
<dd>A sphere.  Properties:
<dl>
<dt><code>radius</code> [<code>number</code>]
<dd>Radius of the sphere.  No default value.
</dl>

<p><dt><code>cylinder</code>
<dd>A cylinder, with circular cross-section and finite height.  Properties:
<dl>
<dt><code>radius</code> [<code>number</code>]
<dd>Radius of the cylinder's cross-section.  No default value.
<dt><code>height</code> [<code>number</code>]
<dd>Length of the cylinder along its axis.  No default value.
<dt><code>axis</code> [<code>vector3</code>]
<dd>Direction of the cylinder's axis; the length of this vector is
ignored.  Defaults to point parallel to the z axis.
</dl>

<p><dt><code>cone</code>

<dd>A cone, or possibly a truncated cone.  This is actually a subclass
of <code>cylinder</code>, and inherits all of the same properties,
with one additional property.  The radius of the base of the cone is
given by the <code>radius</code> property inherited from
<code>cylinder</code>, while the radius of the tip is given by the new
property:
<dl>
<dt><code>radius2</code> [<code>number</code>]
<dd>Radius of the tip of the cone (i.e. the end of the cone pointed to
by the <code>axis</code> vector).  Defaults to zero (a "sharp" cone).
</dl>

<p><dt><code>block</code>
<dd>A parallelepiped (i.e., a brick, possibly with non-orthogonal
axes). Properties:
<dl>
<dt><code>size</code> [<code>vector3</code>]
<dd>The lengths of the block edges along each of its three axes.  Not
really a 3-vector (at least, not in the lattice basis), but it has
three components, each of which should be nonzero.  No default value.
<dt><code>e1</code>, <code>e2</code>, <code>e3</code> [<code>vector3</code>]
<dd>The directions of the axes of the block; the lengths of these
vectors are ignored.  Must be linearly independent.  They default to
the three lattice directions.
</dl>

<p><dt><code>ellipsoid</code>
<dd>An ellipsoid.  This is actually a subclass of <code>block</code>,
and inherits all the same properties, but defines an ellipsoid
inscribed inside the block.

</dl>

<p>Here are some examples of geometric objects created using the above
classes, assuming that the lattice directions (the basis) are just the
ordinary unit axes, and <code>m</code> is some material we have
defined:

<pre>
; A cylinder of infinite radius and height 0.25 pointing along the x axis,
; centered at the origin:
(make cylinder (center 0 0 0) (material m) 
               (radius infinity) (height 0.25) (axis 1 0 0))


; An ellipsoid with its long axis pointing along (1,1,1), centered on
; the origin (the other two axes are orthogonal and have equal
; semi-axis lengths):
(make ellipsoid (center 0 0 0) (material m)
                (size 0.8 0.2 0.2)
		(e1 1 1 1)
		(e2 0 1 -1)
		(e3 -2 1 1))

; A unit cube of material m with a spherical air hole of radius 0.2 at
; its center, the whole thing centered at (1,2,3):
(set! geometry (list
		(make block (center 1 2 3) (material m) (size 1 1 1))
		(make sphere (center 1 2 3) (material air) (radius 0.2))))
</pre>

<h2><a name="functions">Functions</a></h2>

<p>Here, we describe the functions that are defined by the
Photonic-Bands package.  There are many types of functions defined,
ranging from utility functions for duplicating geometric objects to
run functions that start the computation.

<p>See also the <a
href="http://ab-initio.mit.edu/libctl/doc/user-ref.html">reference
section</a> of the libctl manual, which describes a number of useful
functions defined by libctl.

<h3><a name="geom-utils">Geometry utilities</a></h3>

<p>Some utility functions are provided to help you manipulate
geometric objects:

<dl>

<dt><code>(shift-geometric-object <i>obj shift-vector</i>)</code>
<dd>Translate <code>obj</code> by the 3-vector <code>shift-vector</code>.

<p><dt><code>(geometric-object-duplicates <i>shift-vector min-multiple max-multiple obj</i>)</code>
<dd>Return a list of duplicates of <code>obj</code>, shifted by
various multiples of <code>shift-vector</code> (from
<code>min-multiple</code> to <code>max-multiple</code>, inclusive, in
steps of 1).

<p><dt><code>(geometric-objects-duplicates <i>shift-vector min-multiple max-multiple obj-list</i>)</code>
<dd>Same as <code>geometric-object-duplicates</code>, except operates
on a list of objects, <code>obj-list</code>.  If <i>A</i> appears
before <i>B</i> in the input list, then all the duplicates of <i>A</i>
appear before all the duplicates of <i>B</i> in the output list.

<p><dt><code>(geometric-objects-lattice-duplicates <i>obj-list [ ux uy uz ]</i>)</code>
<dd>Duplicates the objects in <code>obj-list</code> by multiples of
the lattice basis vectors, making all possible shifts of the
"primitive cell" (see below) that fit inside the lattice cell.  (This
is useful for supercell calculations; see the <a
href="user-tutorial.html">tutorial</a>.)  The primitive cell to
duplicate is <code>ux</code> by <code>uy</code> by <code>uz</code>, in
units of the basis vectors.  These three parameters are optional; any
that you do not specify are assumed to be <code>1</code>.

<p><dt><code>(point-in-object? <i>point obj</i>)</code>
<dd>Returns whether or not the given 3-vector <code>point</code> is
inside the geometric object <code>obj</code>.

<p><dt><code>(point-in-periodic-object? <i>point obj</i>)</code>
<dd>As <code>point-in-object?</code>, but also checks translations of
the given object by the lattice vectors.

<p><dt><code>(display-geometric-object-info <i>indent-by obj</i>)</code>
<dd>Outputs some information about the given <code>obj</code>,
indented by <code>indent-by</code> spaces.

</dl>

<h3><a name="coordconvert">Coordinate conversion functions</a></h3>

<p>The following functions allow you to easily convert back and forth
between the lattice, cartesian, and reciprocal bases.  (See also the
<a href="user-tutorial.html#units">note on units</a> in the tutorial.)

<dl>

<dt><code>(lattice->cartesian <i>x</i>)</code>, <code>(cartesian->lattice <i>x</i>)</code>
<dd>Convert <code><i>x</i></code> between the lattice basis (the basis
of the lattice vectors normalized to <code>basis-size</code>) and the
ordinary cartesian basis, where <code><i>x</i></code> is either a
<code>vector3</code> or a <code>matrix3x3</code>, returning the
transformed vector/matrix.  In the case of a matrix argument, the
matrix is treated as an operator on vectors in the given basis, and is
transformed into the same operator on vectors in the new basis.

<p><dt><code>(reciprocal->cartesian <i>x</i>)</code>, <code>(cartesian->reciprocal <i>x</i>)</code>
<dd>Like the above, except that they convert to/from reciprocal space
(the basis of the reciprocal lattice vectors).  Also, the cartesian
vectors output/input are in units of 2 Pi.

<p><dt><code>(reciprocal->lattice <i>x</i>)</code>, <code>(lattice->reciprocal <i>x</i>)</code>
<dd>Convert between the reciprocal and lattice bases, where the
conversion again leaves out the factor of 2 Pi (i.e. the lattice-basis
vectors are assumed to be in units of 2 Pi).

</dl>

<p>Also, a couple of rotation functions are defined, for convenience,
so that you don't have to explicitly convert to cartesian coordinates
in order to use libctl's <code>rotate-vector3</code> function (see the
<a href="http://ab-initio.mit.edu/libctl/doc/user-ref.html">libctl
reference</a>):

<dl>

<dt><code>(rotate-lattice-vector3 <i>axis theta v</i>)</code>, <code>(rotate-reciprocal-vector3 <i>axis theta v</i>)</code>
<dd>Like <code>rotate-vector3</code> , except that
<code><i>axis</i></code> and <code><i>v</i></code> are specified in
the lattice/reciprocal bases.

</dl>

<p><a name="first-brillouin-zone"></a>Usually, k-points are specified
in the first Brillouin zone, but sometimes it is convenient to specify
an arbitrary k-point.  However, the accuracy of MPB degrades as you
move farther from the first Brillouin zone (due to the choice of a
fixed planewave set for a basis).  This is easily fixed: simply
transform the k-point to a corresponding point in the first Brillouin
zone, and a completely equivalent solution (identical frequency,
fields, etcetera) is obtained with maximum accuracy.  The following
function accomplishes this:

<dl>

<dt><code>(first-brillouin-zone <i>k</i>)</code>
<dd>Given a k-point <code><i>k</i></code> (in the basis of the
reciprocal lattice vectors, as usual), return an equivalent point in
the first Brillouin zone of the current lattice
(<code>geometry-lattice</code>).

</dl>

<p>Note that <code>first-brillouin-zone</code> can be applied to the
entire <code>k-points</code> list with the Scheme expression:
<code>(map first-brillouin-zone k-points)</code>.

<h3><a name="run">Run functions</a></h3>

<p>These are functions to help you run and control the simulation.
The ones you will most commonly use are the <code>run</code> function
and its variants.  The syntax of these functions, and one lower-level
function, is:

<dl>

<dt><code>(run <i>band-func ...</i>)</code> <dd>This runs the
simulation described by the input parameters (see above), with no
constraints on the polarization of the solution.  That is, it reads
the input parameters, initializes the simulation, and solves for the
requested eigenstates of each k-point.  The dielectric function is
outputted to "<code>epsilon.h5</code>" before any eigenstates are
computed.  <code>run</code> takes as arguments zero or more "band
functions" <code>band-func</code>.  A band function should be a
function of one integer argument, the band index, so that
<code>(band-func which-band)</code> performs some operation on the
band <code>which-band</code> (e.g. outputting fields).  After every
k-point, each band function is called for the indices of all the bands
that were computed.  Alternatively, a band function may be a "thunk"
(function of zero arguments), in which case <code>(band-func)</code>
is called exactly once per k-point.

<p><dt><code>(run-zeven <i>band-func ...</i>), (run-zodd <i>band-func ...</i>)</code>
<dd>These are the same as the <code>run</code> function except that
they constrain their solutions to have even and odd symmetry with
respect to the z=0 plane.  You should use these functions
<em>only</em> for structures that are symmetric through the z=0 mirror
plane, where the third basis vector is in the z direction (0,0,1) and
is orthogonal to the other two basis vectors, and when the k vectors
are in the xy plane.  Under these conditions, the eigenmodes always
have either even or odd symmetry.  In two dimensions, even/odd
parities are equivalent to TE/TM polarizations, respectively (and are
often strongly analogous even in 3d).  Such a symmetry classification
is useful for structures such as waveguides and photonic-crystal slabs.
(For example, see the paper by S. G. Johnson <i>et al.</i>, "Guided
modes in photonic crystal slabs," <i>PRB</i> <b>60</b>, 5751, August
1999.)

<p><dt><code>(run-te <i>band-func ...</i>), (run-tm <i>band-func ...</i>)</code>
<dd>These are the same as the <code>run</code> function except that
they constrain their solutions to be TE- and TM-polarized,
respectively, in two dimensions.  The TE and TM polarizations are
defined has having electric and magnetic fields in the xy plane,
respectively.  Equivalently, the H/E field of TE/TM light has only a z
component (making it easier to visualize).

<p>These functions are actually equivalent to calling
<code>run-zeven</code> and <code>run-zodd</code>, respectively.

<p><a name="tetm-aniso">Note</a> that for the modes to be segregated
into TE and TM polarizations, the dielectric function must have mirror
symmetry for reflections through the xy plane.  If you use <a
href="#dielectric-anisotropic">anisotropic dielectrics</a>, you should
be aware that they break this symmetry if the z direction is not one
of the principle axes.  If you use <code>run-te</code> or
<code>run-tm</code> in such a case of broken symmetry, MPB will exit
with an error.

<p><dt><code>(run-yeven <i>band-func ...</i>), (run-yodd <i>band-func ...</i>)</code>
<dd>These functions are analogous to <code>run-zeven</code> and
<code>run-zodd</code>, except that they constrain their solutions to
have even and odd symmetry with respect to the y=0 plane.  You should
use these functions <em>only</em> for structures that are symmetric
through the y=0 mirror plane, where the second basis vector is in the
y direction (0,1,0) and is orthogonal to the other two basis vectors,
and when the k vectors are in the xz plane.

<p><dt><code>run-yeven-zeven</code>, <code>run-yeven-zodd</code>, <code>run-yodd-zeven</code>, <code>run-yodd-zodd</code>, <code>run-te-yeven</code>, <code>run-te-yodd</code>, <code>run-tm-yeven</code>, <code>run-tm-yodd</code>
<dd>These <code>run</code>-like functions combine the
<code>yeven</code>/<code>yodd</code> constraints with
<code>zeven</code>/<code>zodd</code> or
<code>te</code>/<code>tm</code>.  See also <code>run-parity</code>,
below.

<p><dt><code>(run-parity <i>p reset-fields band-func ...</i>)</code>
<dd>Like the <code>run</code> function, except that it takes two extra
parameters, a parity <code>p</code> and a boolean
(<code>true</code>/<code>false</code>) value
<code>reset-fields</code>.  <code>p</code> specifies a parity
constraint, and should be one of the predefined variables:

<ul>
<li><code>NO-PARITY</code>: equivalent to <code>run</code>
<li><code>EVEN-Z</code> (or <code>TE</code>): equivalent to <code>run-zeven</code> or <code>run-te</code>
<li><code>ODD-Z</code> (or <code>TM</code>): equivalent to <code>run-zodd</code> or <code>run-tm</code>
<li><code>EVEN-Y</code> (like <code>EVEN-Z</code> but for y=0 plane)
<li><code>ODD-Y</code> (like <code>ODD-Z</code> but for y=0 plane)
</ul>

<p>It is possible to specify more than one symmetry constraint
simultaneously by adding them, e.g. <code>(+ EVEN-Z ODD-Y)</code>
requires the fields to be even through z=0 and odd through y=0.  It is
an error to specify incompatible constraints (e.g. <code>(+ EVEN-Z
ODD-Z)</code>).  <b>Important:</b> if you specify the z/y parity, the
dielectric structure (and the k vector) <b>must</b> be symmetric about the
z/y=0 plane, respectively.

<p>If <code>reset-fields</code> is <code>false</code>, the fields from
any previous calculation will be reused as the starting point from
this calculation, if possible; otherwise, the fields are reset to
random values.  The ordinary <code>run</code> functions use a default
<code>reset-fields</code> of<code>true</code>.  Alternatively,
<code>reset-fields</code> may be a string, the name of an HDF5 file to
load the initial fields from (as exported by
<code>save-eigenvectors</code>, <a href="#eigen-fields">below</a>).

<p><dt><code>(display-eigensolver-stats)</code>
<dd>Display some statistics on the eigensolver convergence; this function is
useful mainly for MPB developers in tuning the eigensolver.

</dl>

<p>Several band functions for outputting the eigenfields are defined
for your convenience, and are described in the <b>Band output
functions</b> section, below.  You can also define your own band
functions, and for this purpose the functions described in the section
<b>Field manipulation functions</b>, below, are useful.  A band
function takes the form:

<pre>
(define (<i>my-band-func</i> which-band)
  <i>...do stuff here with band index which-band...</i>
)
</pre>

<p>Note that the output variable <code>freqs</code> may be used to
retrieve the frequency of the band (see above).  Also, a global
variable <code>current-k</code> is defined holding the current k-point
vector from the <code>k-points</code> list.

<p>There are also some even lower-level functions that you can call,
although you should not need to do most of the time:

<dl>

<dt><code>(init-params <i>p reset-fields?</i>)</code>

<dd>Read the input variables and initialize the simulation in
preparation for computing the eigenvalues.  The parameters are the
same as the first two parameters of <code>run-parity</code>.
This function <em>must</em> be called before any of the other
simulation functions below.  (Note, however, that the <code>run</code>
functions all call <code>init-params</code>.)

<p><dt><code>(set-parity <i>p</i>)</code>
<dd>After calling <code>init-params</code>, you can change the
parity constraint without resetting the other parameters by
calling this function.  Beware that this does not randomize the fields
(see below); you don't want to try to solve for, say, the TM
eigenstates when the fields are initialized to TE states from a
previous calculation.

<p><dt><code>(randomize-fields)</code>
<dd>Initialize the fields to random values.

<p><dt><code>(solve-kpoint <i>k</i>)</code>
<dd>Solve for the requested eigenstates at the Bloch wavevector
<code>k</code>.

</dl>

<h3><a name="find-k">The inverse problem: k as a function of frequency</a></h3>

<p>MPB's <code>(run)</code> function(s) and its underlying algorithms
compute the frequency <code>w</code> as a function of wavevector
<code>k</code>.  Sometimes, however, it is desirable to solve the
inverse problem, for <code>k</code> at a given frequency
<code>w</code>.  This is useful, for example, when studying coupling
in a waveguide between different bands at the same frequency
(frequency is conserved even when wavevector is not).  One also uses
<code>k(w)</code> to construct wavevector diagrams, which aid in
understanding diffraction (e.g. negative-diffraction materials and
super-prisms).  To solve such problems, therefore, we provide the
<code>find-k</code> function described below, which inverts
<code>w(k)</code> via a few iterations of Newton's method (using the
<a href="#group-vel">group velocity</a> <code>dw/dk</code>).  Because
it employs a root-finding method, you need to specify bounds on
<code>k</code> and a <em>crude</em> initial guess (order of magnitude
is usually good enough).

<dl>

<dt><code>(find-k <i>p omega band-min band-max kdir
                tol kmag-guess kmag-min kmag-max [band-func...]</i>)</code>

<dd>Find the wavevectors in the current geometry/structure for the
bands from <code><i>band-min</i></code> to
<code><i>band-max</i></code> at the frequency
<code><i>omega</i></code> along the <code><i>kdir</i></code> direction
in k-space.  Returns a list of the wavevector magnitudes for each
band; the actual wavevectors are <code>(vector3-scale <i>magnitude</i>
(unit-vector3 <i>kdir</i>))</code>.  The arguments of
<code>find-k</code> are:

<ul>

<li><code><i>p</i></code>: parity (same as first argument to
<code>run-parity</code>, <a href="#run">above</a>).

<li><code><i>omega</i></code>: the frequency at which to find the bands

<li><code><i>band-min</i></code>, <code><i>band-max</i></code>: the
range of bands to solve for the wavevectors of (inclusive).

<li><code><i>kdir</i></code>: the direction in k-space in which to
find the wavevectors.  (The magnitude of <code><i>kdir</i></code> is
ignored.)

<li><code><i>tol</i></code>: the fractional tolerance with which to
solve for the wavevector; <code>1e-4</code> is usually sufficient.
(Like the <code>tolerance</code> input variable, this is only the
tolerance of the numerical iteration...it does not have anything to do
with e.g. the error from finite grid <code>resolution</code>.)

<li><code><i>kmag-guess</i></code>: an initial guess for the k
magnitude (along <code><i>kdir</i></code>) of the wavevector at
<code><i>omega</i></code>.  Can either be a list (one guess for each
band from <code><i>band-min</i></code> to
<code><i>band-max</i></code>) or a single number (same guess for all
bands, which is usually sufficient).

<li><code><i>kmag-min</i></code>, <code><i>kmag-max</i></code>: a
range of k magnitudes to search; should be large enough to include the
correct k values for all bands.

<li><code><i>band-func</i></code>: zero or more <a
href="#band-funcs">band functions</a>, just as in <code>(run)</code>,
which are evaluated at the computed k points for each band.

</ul>

<p>The <code>find-k</code> routine also prints a line suitable for grepping:

<pre>
kvals: <i>omega</i>, <i>band-min</i>, <i>band-max</i>, <i>kdir-x</i>, <i>kdir-y</i>, <i>kdir-z</i>, <i>k magnitudes...</i>
</pre>

</dl>

<h3><a name="band-funcs">Band/output functions</a></h3>

<p>All of these are functions that, given a band index, output the
corresponding field or compute some function thereof (in the primitive
cell of the lattice).  They are designed to be passed as band
functions to the <code>run</code> routines, although they can also be
called directly.  See also the section on <a href="#field-norm">field
normalizations</a>.

<dl>

<dt><code>(output-hfield <i>which-band</i>)</code>
<dt><code>(output-hfield-x <i>which-band</i>)</code>
<dt><code>(output-hfield-y <i>which-band</i>)</code>
<dt><code>(output-hfield-z <i>which-band</i>)</code>
<dd>Output the magnetic (H) field for <code>which-band</code>; either
all or one of the components, respectively.

<p><dt><code>(output-dfield <i>which-band</i>)</code>
<dt><code>(output-dfield-x <i>which-band</i>)</code>
<dt><code>(output-dfield-y <i>which-band</i>)</code>
<dt><code>(output-dfield-z <i>which-band</i>)</code>
<dd>Output the electric displacement (D) field for
<code>which-band</code>; either all or one of the components,
respectively.

<p><dt><code>(output-efield <i>which-band</i>)</code>
<dt><code>(output-efield-x <i>which-band</i>)</code>
<dt><code>(output-efield-y <i>which-band</i>)</code>
<dt><code>(output-efield-z <i>which-band</i>)</code>
<dd>Output the electric (E) field for <code>which-band</code>; either
all or one of the components, respectively.

<p><dt><code>(output-hpwr <i>which-band</i>)</code>
<dd>Output the time-averaged magnetic-field energy density (hpwr =
|<b>H</b>|<sup><small>2</small></sup>) for <code>which-band</code>.

<p><dt><code>(output-dpwr <i>which-band</i>)</code>
<dd>Output the time-averaged electric-field energy density (dpwr =
epsilon*|<b>E</b>|<sup><small>2</small></sup>) for
<code>which-band</code>.

<p><dt><code>(fix-hfield-phase <i>which-band</i>)</code>
<dt><code>(fix-dfield-phase <i>which-band</i>)</code>
<dt><code>(fix-efield-phase <i>which-band</i>)</code>
<dd>Fix the phase of the given eigenstate in a canonical way based on
the given spatial field (see also <code>fix-field-phase</code>,
below).  Otherwise, the phase is random; these functions also maximize
the real part of the given field so that one can hopefully just
visualize the real part.  To fix the phase for output, pass one of
these functions to <code>run</code> before the corresponding output
function, e.g. <code>(run-tm fix-dfield-phase output-dfield-z)</code>

<p>Although we try to maximize the "real-ness" of the field, this has
a couple of limitations.  First, the phase of the different field
components cannot, of course, be chosen independently, so an
individual field component may still be imaginary.  Second, if you use
<code>mpbi</code> to take advantage of <a href="#inv-symmetry">inversion
symmetry</a> in your problem, the phase is mostly determined elsewhere
in the program; <code>fix-_field-phase</code> in that case only
determines the sign.

</dl>

<p>See also below for the <code>output-poynting</code> and
<code>output-tot-pwr</code> functions to output the Poynting vector
and the total electromagnetic energy density, respectively.

<p>Sometimes, you only want to output certain bands.  For example,
here is a function that, given an band/output function like the ones
above, returns a new output function that only calls the first
function for bands with a large fraction of their energy in an object(s).
(This is useful for picking out defect states in supercell
calculations.)

<dl>

<dt><code>(output-dpwr-in-objects <i>band-func min-energy objects...</i>)</code>

<dd>Given a band function <code>band-func</code>, returns a new band
function that only calls <code>band-func</code> for bands having a
fraction of their electric-field energy greater than
<code>min-energy</code> inside the given objects (zero or more
geometric objects).  Also, for each band, prints the fraction of their
energy in the objects in the following form (suitable for grepping):

<pre>
dpwr:, <i>band-index</i>, <i>frequency</i>, <i>energy-in-objects</i>
</pre>

</dl>

<p><code>output-dpwr-in-objects</code> only takes a single band
function as a parameter, but if you want it to call several band
functions, you can easily combine them into one with the following
routine:

<dl>

<dt><code>(combine-band-functions <i>band-funcs...</i>)</code>
<dd>Given zero or more band functions, returns a new band function
that calls all of them in sequence.  (When passed zero parameters,
returns a band function that does nothing.)

</dl>

<p>It is also often useful to output the fields only at a certain k-point,
to let you look at typical field patterns for a given band while avoiding
gratuitous numbers of output files.  This can be accomplished via:

<dl>

<dt><code>(output-at-kpoint <i>k-point</i> <i>band-funcs...</i>)</code>
<dd>Given zero or more band functions, returns a new band function
that calls all of them in sequence, but only at the specified
<code>k-point</code>.  For other k-points, does nothing.

</dl>

<h3><a name="misc-funcs">Miscellaneous functions</a></h3>

<dl>

<p><dt><code>(retrieve-gap <i>lower-band</i>)</code>
<dd>Return the frequency gap from the band
#<code><i>lower-band</i></code> to the band
#(<code><i>lower-band</i></code>+1), as a percentage of mid-gap
frequency.  The "gap" may be negative if the maximum of the lower band
is higher than the minimum of the upper band.  (The gap is computed
from the <code>band-range-data</code> of the previous run.)

</dl>

<h4><a name="parity">Parity</a></h4>

<p>Given a set of eigenstates at a k-point, MPB can compute their
<i>parities</i> with respect to the z=0 or y=0 plane.  The z/y parity
of a state is defined as the expectation value (under the usual inner
product) of the mirror-flip operation through z/y=0, respectively.
For true even and odd eigenstates (see e.g.  <code>run-zeven</code>
and <code>run-zodd</code>), this will be +1 and -1, respectively; for
other states it will be something in between.

<p>This is useful e.g. when you have a nearly symmetric structure, such
as a waveguide with a substrate underneath, and you want to tell which
bands are even-like (parity &gt; 0) and odd-like (parity &lt; 0).
Indeed, any state can be decomposed into purely even and odd
functions, with absolute-value-squared amplitudes of (1+parity)/2 and
(1-parity)/2, respectively.

<dl>

<p><dt><code>display-zparities</code>, <code>display-yparities</code>
<dd>These are band functions, designed to be passed to
<code>(run)</code>, which output all of the z/y parities,
respectively, at each k-point (in comma-delimited format suitable for
grepping).

<p><dt><code>(compute-zparities)</code>
<dd>Returns a list of the parities about the z=0 plane, one number for
each band computed at the last k-point.

<p><dt><code>(compute-yparities)</code>
<dd>Returns a list of the parities about the y=0 plane, one number for
each band computed at the last k-point.

</dl>

<p>(The reader should recall that the magnetic field is only a
pseudo-vector, and is therefore multiplied by -1 under mirror-flip
operations.  For this reason, the magnetic field <i>appears</i> to have
opposite symmetry from the electric field, but is really the same.)

<h4><a name="group-vel">Group velocities</a></h4>

<p>Given a set of eigenstates at a given k-point, MPB can compute
their group velocities (the derivative of frequency with respect to
wavevector) using the Hellman-Feynmann theorem.  Three functions are
provided for this purpose, and we document them here from
highest-level to lowest-level.

<dl>

<p><dt><code>display-group-velocities</code>
<dd>This is a band function, designed to be passed to
<code>(run)</code>, which outputs all of the group velocity vectors
(in the Cartesian basis, in units of <i>c</i>) at each k-point.

<p><dt><code>(compute-group-velocities)</code>
<dd>Returns a list of group-velocity vectors (in the Cartesian basis,
units of <i>c</i>) for the bands at the last-computed k-point.

<p><dt><code>(compute-group-velocity-component <i>direction</i>)</code>
<dd>Returns a list of the group-velocity components (units of
<i>c</i>) in the given <i>direction</i>, one for each band at the
last-computed k-point.  <i>direction</i> is a vector in the
reciprocal-lattice basis (like the k-points); its length is ignored.
(This has the advantage of being three times faster than
<code>compute-group-velocities</code>.)

</dl>

<h2><a name="field">Field manipulation</a></h2>

<p>The Photonic-Bands package provides a number of ways to take the
field of a band and manipulate, process, or output it.  These methods
usually work in two stages.  First, one loads a field into memory
(computing it in position space) by calling one of the
<code>get</code> functions below.  Then, other functions can be called
to transform or manipulate the field.

<p>The simplest class of operations involve only the currently-loaded
field, which we describe in the <a href="#cur-field">second
subsection</a> below.  To perform more sophisticated operations,
involving more than one field, one must copy or transform the current
field into a new field variable, and then call one of the functions
that operate on multiple field variables (described in the <a
href="#mult-fields">third subsection</a>).

<h3><a name="field-norm">Field normalization</a></h3>

<p>In order to perform useful operations on the fields, it is
important to understand how they are normalized.  We normalize the
fields in the way that is most convenient for perturbation and
coupled-mode theory [c.f. SGJ et al., <i>PRE</i> <b>65</b>, 066611
(2002)], so that their energy densities have unit integral.  In
particular, we normalize the electric (<b>E</b>), displacement
(<b>D</b> = epsilon*<b>E</b>) and magnetic (<b>H</b> = -i/omega * curl
<b>E</b>) fields, so that:

<ul>

<li>integral epsilon*|<b>E</b>|<sup><small>2</small></sup> dxdydz = 1
<li>integral |<b>H</b>|<sup><small>2</small></sup> dxdydz = 1

</ul>

<p>where the integrals are over the computational cell.  Note the
volume element dxdydz (the volume of a grid pixel/voxel).  If you
simply sum |<b>H</b>|<sup><small>2</small></sup> over all the grid
points, therefore, you will get (# grid points) / (volume of cell).

<p>Note that we have dropped the pesky factors of 1/2, pi, etcetera
from the energy densities, since these do not appear in
e.g. perturbation theory, and the fields have arbitrary units anyway.
The functions to compute/output energy densities below similarly use
epsilon*|<b>E</b>|<sup><small>2</small></sup> and
|<b>H</b>|<sup><small>2</small></sup> without any prefactors.

<h3><a name="cur-field">Loading and manipulating the current
field</a></h3>

<p>In order to load a field into memory, call one of the
<code>get</code> functions follow.  They should only be called after
the eigensolver has run (or after <code>init-params</code>, in the
case of <code>get-epsilon</code>).  One normally calls them after
<code>run</code>, or in one of the band functions passed to
<code>run</code>.

<dl>

<dt><code>(get-hfield <i>which-band</i>)</code>
<dd>Loads the magnetic (H) field for the band <code>which-band</code>.

<p><dt><code>(get-dfield <i>which-band</i>)</code>
<dd>Loads the electric displacement (D) field for the band
<code>which-band</code>.

<p><dt><code>(get-efield <i>which-band</i>)</code>
<dd>Loads the electric (E) field for the band <code>which-band</code>.
(This function actually calls <code>get-dfield</code> followed by
<code>get-efield-from-dfield</code>, below.)

<p><dt><code>(get-epsilon)</code>
<dd>Loads the dielectric function.

</dl>

<p>Once loaded, the field can be transformed into another field or a
scalar field:

<dl>

<dt><code>(get-efield-from-dfield)</code>
<dd>Multiplies by the inverse dielectric tensor to compute the
electric field from the displacement field.  Only works if a D field
has been loaded.

<p><dt><code>(fix-field-phase)</code>
<dd>Fix the currently-loaded eigenstate's phase (which is normally
random) in a canonical way, based on the spatial field (H, D, or E)
that has currently been loaded.  The phase is fixed to make the real
part of the spatial field as big as possible (so that you can
hopefully visualize just the real part of the field), and a canonical
sign is chosen.  See also the <code>fix-*field-phase</code> band
functions, above, which are convenient wrappers around
<code>fix-field-phase</code>

<p><dt><code>(compute-field-energy)</code>
<dd>Given the H or D fields, computes the corresponding energy density
function (normalized by the total energy in H or D, respectively).  Also
prints the fraction of the field in each of its cartesian components
in the following form (suitable for grepping):

<pre>
<i>f</i>-energy-components:, <i>k-index</i>, <i>band-index</i>, <i>x-fraction</i>, <i>y-fraction</i>, <i>z-fraction</i>
</pre>

<p>where <code><i>f</i></code> is either <code>h</code> or
<code>d</code>.  The return value of <code>compute-field-energy</code>
is a list of 7 numbers: <code>(<i>U xr xi yr yi zr zi</i>)</code>.
<code><i>U</i></code> is the total, unnormalized energy, which is in
arbitrary units deriving from the normalization of the eigenstate
(e.g. the total energy for H is always 1.0).  <code><i>xr</i></code>
is the fraction of the energy in the real part of the field's x
component, <code><i>xi</i></code> is the fraction in the imaginary
part of the x component, etcetera (<code><i>yr + yi =
y-fraction</i></code>, and so on).

</dl>

<p>Various integrals and other information about the eigenstate can be
accessed by the following functions, useful e.g. for perturbation
theory.  Functions dealing with the field vectors require a field to
be loaded, and functions dealing with the energy density require an
energy density to be loaded via <code>compute-field-energy</code>.

<dl>

<dt><code>(compute-energy-in-dielectric <i>min-eps max-eps</i>)</code>
<dd>Returns the fraction of the energy that resides in dielectrics
with epsilon in the range <code>min-eps</code> to
<code>max-eps</code>.

<p><dt><code>(compute-energy-in-objects <i>objects...</i>)</code>
<dd>Returns the fraction of the energy inside zero or more geometric
objects.

<p><dt><code>(compute-energy-integral <i>f</i>)</code>
<dd><code><i>f</i></code> is a function <code>(<i>f u eps
r</i>)</code> that returns a number given three parameters:
<code><i>u</i></code>, the energy density at a point;
<code><i>eps</i></code>, the dielectric constant at the same point;
and <code><i>r</i></code>, the position vector (in lattice
coordinates) of the point.  <code>compute-energy-integral</code>
returns the integral of <code><i>f</i></code> over the unit cell.
(The integral is computed simply as the sum over the grid points times
the volume of a grid pixel/voxel.)  This can be useful e.g. for
perturbation-theory calculations.

<p><dt><code>(compute-field-integral <i>f</i>)</code>
<dd>Like <code>compute-energy-integral</code>, but
<code><i>f</i></code> is a function <code>(<i>f F eps r</i>)</code>
that returns a number (possibly complex) where <code><i>F</i></code>
is the complex field vector at the given point.

<p><dt><code>(get-epsilon-point <i>r</i>)
<dd>Given a position vector <code><i>r</i></code> (in lattice
coordinates), return the interpolated dielectric constant at that
point.  (Since MPB uses a an effective dielectric tensor internally,
this actually returns the mean dielectric constant.)

<p><dt><code>(get-epsilon-inverse-tensor-point <i>r</i>)
<dd>Given a position vector <code><i>r</i></code> (in lattice
coordinates), return the interpolated inverse dielectric tensor (a 3x3
matrix) at that point.  (Near a dielectric interface, the effective
dielectric constant is a tensor even if you input only scalar
dielectrics; see the <a href="developer.html#epsilon">epsilon
overview</a> for more information.)  The returned matrix may be
complex-Hermetian if you are employing magnetic materials.

<p><dt><code>(get-energy-point <i>r</i>)
<dd>Given a position vector <code><i>r</i></code> (in lattice
coordinates), return the interpolated energy density at that point.

<p><dt><code>(get-field-point <i>r</i>)
<dd>Given a position vector <code><i>r</i></code> (in lattice
coordinates), return the interpolated (complex) field vector at that point.

<p><dt><code>(get-bloch-field-point <i>r</i>)
<dd>Given a position vector <code><i>r</i></code> (in lattice
coordinates), return the interpolated (complex) Bloch field vector at that
point (this is the field without the exp(ikx) envelope).

</dl>

<p>Finally, we have the following functions to output fields (either
the vector fields, the scalar energy density, or epsilon), with the
option of outputting several periods of the lattice.

<dl>

<dt><code>(output-field <i>[ nx [ ny [ nz ] ] ]</i>)</code>
<dt><code>(output-field-x <i>[ nx [ ny [ nz ] ] ]</i>)</code>
<dt><code>(output-field-y <i>[ nx [ ny [ nz ] ] ]</i>)</code>
<dt><code>(output-field-z <i>[ nx [ ny [ nz ] ] ]</i>)</code>
<dd>Output the currently-loaded field.  The optional (as indicated by
the brackets) parameters <code>nx</code>, <code>ny</code>, and
<code>nz</code> indicate the number of periods to be outputted along
each of the three lattice directions.  Omitted parameters are assumed
to be 1.  For vector fields, <code>output-field</code> outputs all of
the components, while the other variants output only one component.

<p><dt><code>(output-epsilon <i>[ nx [ ny [ nz ] ] ]</i>)</code>

<dd>A shortcut for calling <code>get-epsilon</code> followed by
<code>output-field</code>.  Note that, because epsilon is a tensor, a
number of datasets are outputted in <code>"epsilon.h5"</code>:

<ul>
<li><code>"data"</code>: 3/trace(1/epsilon)
<li><code>"epsilon.{xx,xy,xz,yy,yz,zz}"</code>: the components of the
(symmetric) dielectric tensor.
<li><code>"epsilon_inverse.{xx,xy,xz,yy,yz,zz}"</code>: the components of the
(symmetric) inverse dielectric tensor.
</ul>

</dl>

<h3><a name="mult-fields">Storing and combining multiple fields</a></h3>

<p>In order to perform operations involving multiple fields,
e.g. computing the Poynting vector <b>E</b>x<b>H</b>, they must be
stored in field variables.  Field variables come in two flavors,
real-scalar (rscalar) fields, and complex-vector (cvector) fields.
There is a pre-defined field variable <code>cur-field</code>
representing the currently-loaded field (see above), and you can
"clone" it to create more field variables with one of:


<dl>

<dt><code>(field-make <i>f</i>)</code>
<dd>Return a new field variable of the same type and size as the field
variable <code><i>f</i></code>.  Does <em>not</em> copy the field
contents (see <code>field-copy</code> and <code>field-set!</code>,
below).

<p><dt><code>(rscalar-field-make <i>f</i>)</code>
<dt><code>(cvector-field-make <i>f</i>)</code>
<dd>Like <code>field-make</code>, but return a real-scalar or
complex-vector field variable, respectively, of the same size as
<code><i>f</i></code> but ignoring <code><i>f</i></code>'s type.

<p><dt><code>(field-set! <i>fdest fsrc</i>)</code>
<dd>Set <code><i>fdest</i></code> to store the same field values as
<code><i>fsrc</i></code>, which must be of the same size and type.

<p><dt><code>(field-copy <i>f</i>)</code>
<dd>Return a new field variable that is exact copy of
<code><i>f</i></code>; this is equivalent to calling
<code>field-make</code> followed by <code>field-set!</code>.

<p><dt><code>(field-load <i>f</i>)</code>

<dd>Loads the field <code><i>f</i></code> as the current field, at
which point you can use all of the functions in the <a
href="#cur-field">previous section</a> to operate on it or output it.

</dl>

<p>Once you have stored the fields in variables, you probably want to
compute something with them.  This can be done in three ways:
combining fields into new fields with <code>field-map!</code>
(e.g. combine <b>E</b> and <b>H</b> to <b>E</b>x<b>H</b>), integrating
some function of the fields with <code>integrate-fields</code>
(e.g. to compute coupling integrals for perturbation theory), and
getting the field values at arbitrary points with
<code>*-field-get-point</code> (e.g. to do a line or surface integral).
These three functions are described below:

<dl>

<dt><code>(field-map! <i>fdest func [f1 f2 ...]</i>)</code>
<dd>Compute the new field <code><i>fdest</i></code> to be
<code>(<i>func f1-val f2-val ...</i>)</code> at each point in the
grid, where <code><i>f1-val</i></code> etcetera is the corresponding
value of <code><i>f1</i></code> etcetera.  All the fields must be of
the same size, and the argument and return types of
<code><i>func</i></code> must match those of the
<code><i>f1...</i></code> and <code><i>fdest</i></code> fields,
respectively.  <code><i>fdest</i></code> may be the same field as one
of the <code><i>f1...</i></code> arguments.  Note: all fields are
<em>without</em> Bloch phase factors exp(ikx).

<p><dt><code>(integrate-fields <i>func [f1 f2 ...]</i>)</code>
<dd>Compute the integral of the function <code>(<i>func r [f1 f2
...]</i>)</code> over the computational cell, where
<code><i>r</i></code> is the position (in the usual lattice basis) and
<code><i>f1</i></code> etc. are fields (which must all be of the same
size).  (The integral is computed simply as the sum over the grid
points times the volume of a grid pixel/voxel.) Note: all fields are
<em>without</em> Bloch phase factors exp(ikx).  See also the note <a
href="#mult-fields-bloch">below</a>.


<p>
<dt><code>(cvector-field-get-point <i>f r</i>)</code>
<dt><code>(cvector-field-get-point-bloch <i>f r</i>)</code>
<dt><code>(rscalar-field-get-point <i>f r</i>)</code>
<dd>Given a position vector <code><i>r</i></code> (in lattice
coordinates), return the interpolated field cvector/rscalar from
<code><i>f</i></code> at that point.
<code>cvector-field-get-point-bloch</code> returns the field
<em>without</em> the exp(ikx) Bloch wavevector, in analogue to
<code>get-bloch-field-point</code>.

</dl>

<p>You may be wondering how to get rid of the field variables once you
are done with them: you don't, since they are <a
href="http://www.catb.org/~esr/jargon/html/entry/GC.html">garbage
collected</a> automatically.

<p>We also provide functions, in analogue to e.g <code>get-efield</code>
and <code>output-efield</code> above, to "get" various useful
functions as the <a href="#cur-field">current field</a> and to output
them to a file:

<dl>

<dt><code>(get-poynting <i>which-band</i>)</code>
<dd>Loads the Poynting vector
<b>E</b><sup><small>*</small></sup>x<b>H</b> for the band
<code>which-band</code>, the flux density of electromagnetic energy
flow, as the current field.  1/2 of the real part of this vector is the
time-average flux density (which can be combined with the imaginary
part to determine the amplitude and phase of the time-dependent flux).

<p><dt><code>(output-poynting <i>which-band</i>)</code>
<dt><code>(output-poynting-x <i>which-band</i>)</code>
<dt><code>(output-poynting-y <i>which-band</i>)</code>
<dt><code>(output-poynting-z <i>which-band</i>)</code>
<dd>Output the Poynting vector field for <code>which-band</code>; either
all or one of the components, respectively.

<p><dt><code>(get-tot-pwr <i>which-band</i>)</code>
<dd>Load the time-averaged electromgnetic-field energy density
(|<b>H</b>|<sup><small>2</small></sup> +
epsilon*|<b>E</b>|<sup><small>2</small></sup>) for
<code>which-band</code>.  (If you multiply the real part of the
Poynting vector by a factor of 1/2, above, you should multiply by a
factor of 1/4 here for consistency.)

<p><dt><code>(output-tot-pwr <i>which-band</i>)</code>
<dd>Output the time-averaged electromgnetic-field energy density
(above) for <code>which-band</code>.

</dl>

<p>As an example, below is the Scheme source code for the
<code>get-poynting</code> function, illustrating the use of the
various field functions:

<pre>
(define (get-poynting which-band)
  (get-efield which-band)                      ; put E in cur-field
  (let ((e (field-copy cur-field)))            ; ... and copy to local var.
    (get-hfield which-band)                    ; put H in cur-field
    (field-map! cur-field                      ; write ExH to cur-field
                (lambda (e h) (vector3-cross (vector3-conj e) h))
                e cur-field)
    (cvector-field-nonbloch! cur-field)))      ; see below
</pre>

<h4><a name="mult-fields-bloch">Stored fields and Bloch phases</a></h3>

<p>Complex vector fields like <b>E</b> and <b>H</b> as computed by MPB
are physically of the Bloch form: exp(ikx) times a periodic function.
What MPB actually stores, however, is just the periodic function, the
Bloch envelope, and only multiplies by exp(ikx) for when the fields
are output or passed to the user (e.g. in integration functions).
This is mostly transparent, with a few exceptions noted above for
functions that do not include the exp(ikx) Bloch phase (it is somewhat
faster to operate without including the phase).

<p>On some occasions, however, when you create a field with
<code>field-map!</code>, the resulting field should <em>not</em> have
any Bloch phase.  For example, for the Poynting vector
<b>E</b><sup><small>*</small></sup>x<b>H</b>, the exp(ikx) cancels
because of the complex conjugation.  After creating this sort of
field, we must use the special function
<code>cvector-field-nonbloch!</code> to tell MPB that the field is
purely periodic:

<dl>

<dt><code>(cvector-field-nonbloch! <i>f</i>)</code>
<dd>Specify that the field <code><i>f</i></code> is <em>not</em> of
the Bloch form, but rather that it is purely periodic.

</dl>

<p>Currently, all fields must be either Bloch or non-Bloch (i.e. periodic),
which covers most physically meaningful possibilities.

<p>There is another wrinkle: even for fields in Bloch form, the
exp(ikx) phase currently always uses the <em>current</em> k-point,
even if the field was computed from another k-point.  So, if you are
performing computations combining fields from different k-points, you
should take care to always use the periodic envelope of the field,
putting the Bloch phase in manually if necessary.

<h3><a name="eigen-fields">Manipulating the raw eigenvectors</a></h3>

<p>MPB also includes a few low-level routines to manipulate the raw
eigenvectors that it computes in a transverse planewave basis.

<p>The most basic operations involve copying, saving, and restoring
the current set of eigenvectors or some subset thereof:

<dl>

<dt><code>(get-eigenvectors <i>first-band num-bands</i>)</code>
<dd>Return an eigenvector object that is a copy of
<code><i>num-bands</i></code> current eigenvectors starting at
<code><i>first-band</i></code>.  e.g. to get a copy of all of the
eigenvectors, use <code>(get-eigenvectors 1 num-bands)</code>.

<p><dt><code>(set-eigenvectors <i>ev first-band</i>)</code>
<dd>Set the current eigenvectors, starting at
<code><i>first-band</i></code>, to those in the <code><i>ev</i></code>
eigenvector object (as returned by <code>get-eigenvectors</code>).
(Does not work if the grid sizes don't match)

<p><dt><code>(load-eigenvectors <i>filename</i>)</code>
<dt><code>(save-eigenvectors <i>filename</i>)</code>
<dd>Read/write the current eigenvectors (raw planewave amplitudes)
to/from an HDF5 file named <code><i>filename</i></code>.  Instead of
using <code>load-eigenvectors</code> directly, you can pass the
<code><i>filename</i></code> as the <code><i>reset-fields</i></code>
parameter of <code>run-parity</code>, <a href="#run">above</a>.
(Loaded eigenvectors must be of the same size (same grid size and
#bands) as the current settings.)

</dl>

<p>Currently, there's only one other interesting thing you can do with
the raw eigenvectors, and that is to compute the dot-product matrix
between a set of saved eigenvectors and the current eigenvectors.
This can be used, e.g., to detect band crossings or to set phases
consistently at different k points.  The dot product is returned as a
"sqmatrix" object, whose elements can be read with the
<code>sqmatrix-size</code> and <code>sqmatrix-ref</code> routines.

<dl>

<dt><code>(dot-eigenvectors <i>ev first-band</i>)</code>
<dd>Returns a sqmatrix object containing the dot product of the saved
eigenvectors <code><i>ev</i></code> with the current eigenvectors,
starting at <code><i>first-band</i></code>.  That is, the (i,j)th
output matrix element contains the dot product of the (i+1)th vector
of <code><i>ev</i></code> (conjugated) with the
(<code><i>first-band</i></code>+j)th eigenvector.  Note that the
eigenvectors, when computed, are orthonormal, so the dot product of
the eigenvectors with themselves is the identity matrix.

<p><dt><code>(sqmatrix-size <i>sm</i>)</code>
<dd>Return the size <i>n</i> of an <i>n</i>x<i>n</i> sqmatrix
<code><i>sm</i></code>.

<p><dt><code>(sqmatrix-ref <i>sm i j</i>)</code>
<dd>Return the (<code><i>i</i></code>,<code><i>j</i></code>)th element
of the <i>n</i>x<i>n</i> sqmatrix <code><i>sm</i></code>, where
{<code><i>i</i></code>,<code><i>j</i></code>} range from
0..<i>n</i>-1.

</dl>

<h2><a name="inv-symmetry">Inversion Symmetry</a></h2>

<p>If you <code>configure</code> MPB with the
<code>--with-inv-symmetry</code> flag, then the program is configured
to assume inversion symmetry in the dielectric function.  This allows
it to run at least twice as fast and use half as much memory as the
more general case.  This version of MPB is by default installed as
<code>mpbi</code>, so that it can coexist with the usual
<code>mpb</code> program.

<p>Inversion symmetry means that if you transform (x,y,z) to
(-x,-y,-z) in the coordinate system, the dielectric structure is not
affected.  Or, more technically, that:

<p align=center>epsilon(x,y,z) =
epsilon(-x,-y,-z)<sup><small>*</small></sup>,

<p>where the conjugation is significant for <a
href="#dielectric-anisotropic">complex-hermitian dielectric
tensors</a>.  This symmetry is very common; all of the examples in
this manual have inversion symmetry, for example.

<p>Note that inversion symmetry is defined with respect to a specific
origin, so that you may "break" the symmetry if you define a given
structure in the wrong way--this will prevent <code>mpbi</code> from
working properly.  For example, the <a
href="analysis-tutorial.html#diamond">diamond structure</a> that we
considered earlier would not have possessed inversion symmetry had we
positioned one of the "atoms" to lie at the origin.

<p>You might wonder what happens if you pass a structure lacking
inversion symmetry to <code>mpbi</code>.  As it turns out,
<code>mpbi</code> only looks at half of the structure, and infers the
other half by the inversion symmetry, so the resulting structure
<em>always</em> has inversion symmetry, even if its original
description did not.  So, you should be careful, and look at the
<code>epsilon.h5</code> output to make sure it is what you expected.

<h2><a name="parallel">Parallel MPB</a></h2>

<p>We provide two methods by which you can parallelize MPB.  The
first, using MPI, is the most sophisticated and potentially provides
the greatest and most general benefits.  The second, which involves a
simple script to split e.g. the <code>k-points</code> list among
several processes, is less general but may be useful in many cases.

<h3><a name="mpb-mpi">MPB with MPI parallelization</a></h3>

<p>If you <code>configure</code> MPB with the <code>--with-mpi</code>
flag, then the program is compiled to take advantage of
distributed-memory parallel machines with <a
href="http://www-unix.mcs.anl.gov/mpi/index.html">MPI</a>, and is
installed as <code>mpb-mpi</code>.  (See also the <a
href="installation.html#mpi">installation section</a>.)  This means
that computations will (potentially) run more quickly and take up less
memory per processor than for the serial code.

<p>Using the parallel MPB is almost identical to using the serial
version(s), with a couple of minor exceptions.  The same ctl files should
work for both.  Running a program that uses MPI requires slightly
different invocations on different systems, but will typically be
something like:

<pre>
unix% mpirun -np 4 mpb-mpi foo.ctl
</pre>

<p>to run on e.g. 4 processors.  A second difference is that 1D
systems are currently not supported in the MPI code, but the serial
code should be fast enough for those anyway.  A third difference is
that the output HDF5 files (epsilon, fields, etcetera) from
<code>mpb-mpi</code> have their first two dimensions (x and y)
<em>transposed</em>; i.e. they are output as YxXxZ arrays.  This
doesn't prevent you from visualizing them, but the coordinate system
is left-handed; to un-transpose the data, you can process it with
<code>mpb-data</code> and the <code>-T</code> option (in addition to
any other options).

<p>In order to get optimal benefit (time and memory savings) from
<code>mpb-mpi</code>, the first two dimensions
(n<sub><small>x</small></sub> and n<sub><small>y</small></sub>) of
your grid should <em>both</em> be divisible by the number of
processes.  If you violate this constraint, MPB will still work, but
the load balance between processors will be uneven.  At worst, e.g. if
either n<sub><small>x</small></sub> or n<sub><small>y</small></sub> is
smaller than the number of processes, then some of the processors will
be idle for part (or all) of the computation.  When using <a
href="#inv-symmetry">inversion symmetry</a> (<code>mpbi-mpi</code>)
for 2D grids, the optimal case is somewhat more complicated:
n<sub><small>x</small></sub> and (n<sub><small>y</small></sub>/2 + 1),
not n<sub><small>y</small></sub>, should both be divisible by the
number of processes.

<p><code>mpb-mpi</code> divides each band at each k-point between the
available processors.  This means that, even if you have only a single
k-point (e.g. in a defect calculation) and/or a single band, it can
benefit from parallelization.  Moreover, memory usage per processor is
inversely proportional to the number of processors used.  For
sufficiently large problems, the speedup is also nearly linear.

<p>MPI support in MPB is thanks to generous support from <a
href="http://www.clarendonphotonics.com/">Clarendon Photonics</a>.

<h3><a name="mpb-split">Alternative parallelization: mpb-split</a></h3>

<p>There is an alternative method of parallelization when you have
multiple k points: do each k-point on a different processor.  This
does not provide any memory benefits, and does not allow one k-point
to benefit by starting with the fields of the previous k-point, but is
easy and may be the only effective way to parallelize calculations for
small problems.  This method also does not require MPI: it can utilize
the unmodified serial <code>mpb</code> program.  To make it even
easier, we supply a simple script called <code>mpb-split</code> (or
<code>mpbi-split</code>) to break the <code>k-points</code> list into
chunks for you.  Running:

<pre>
unix% mpb-split <i>num-split</i> foo.ctl
</pre>

<p>will break the <code>k-points</code> list in <code>foo.ctl</code>
into <code><i>num-split</i></code> more-or-less equal chunks, launch
<code><i>num-split</i></code> processes of <code>mpb</code> in
parallel to process each chunk, and output the results of each in
order.  (Each process is an ordinary <code>mpb</code> execution,
except that it numbers its <code>k-points</code> depending upon which
chunk it is in, so that output files will not overwrite one another
and you can still <code>grep</code> for frequencies as usual.)

<p>Of course, this will only benefit you on a system where different
processes will run on different processors, such as an SMP or a
cluster with automatic process migration (e.g. <a
href="http://www.mosix.org/">MOSIX</a>).  <code>mpb-split</code> is
actually a trivial shell script, though, so you can easily modify it
if you need to use a special command to launch processes on other
processors/machines (e.g. via <a
href="http://www.gnuqueue.org/home.html">GNU Queue</a>).

<p>The general syntax for <code>mpb-split</code> is:

<pre>
unix% mpb-split <i>num-split mpb-arguments...</i>
</pre>

<p>where all of the arguments following <code><i>num-split</i></code>
are passed along to <code>mpb</code>.  What <code>mpb-split</code>
technically does is to set the MPB variable <code>k-split-num</code>
to <code><i>num-split</i></code> and <code>k-split-index</code> to the
index (starting with 0) of the chunk for each process.  If you want,
you can use these variables to divide the problem in some other way
and then reset them to <code>1</code> and <code>0</code>,
respectively.

<hr>
Go to the <a href="developer.html">next</a>, <a href="analysis-tutorial.html">previous</a>, or <a href="index.html">main</a> section.

</BODY>
</HTML>
