; Copyright (C) 1999, 2000 Massachusetts Institute of Technology.
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

; ****************************************************************

(define-class material-type no-parent)

(define-class dielectric material-type
  (define-property epsilon 'number no-default positive?))

(define (index n) (epsilon (* n n))) ; convenient substitute for epsilon

(define-class dielectric-anisotropic material-type
  (define-property epsilon-diag 'vector3 no-default)
  (define-property epsilon-offdiag 'vector3 (make-default (vector3 0 0 0))))

; use the solid geometry classes, variables, etcetera in libgeom:
; (one specifications file can include another specifications file)
(include "@LIBCTL_DIR@/utils/geom.scm")

; ****************************************************************

; eigensolver flags (grabbed from eigensolver.h by configure)

; first, we must define a function (pow2 n) to return 2^n:
(define (pow2 n) (if (<= n 0) 1 (* 2 (pow2 (- n 1)))))

@EIGS_FLAGS_SCM@ ; substituted by configure script

; ****************************************************************

; More input/output variables (besides those defined by libgeom, above).

(define-input-var k-points '() (make-list-type 'vector3))

(define-input-var num-bands 1 'integer)
(define-input-var tolerance 1.0e-4 'number positive?)
(define-input-var target-freq 0.0 'number (lambda (x) (>= x 0)))

(define-input-var grid-size (vector3 16 16 16) 'vector3
  (lambda (v) (vector-for-all? v (lambda (x) (and (> x 0) (integer? x))))))
(define-input-var mesh-size 3 'integer positive?)

(define-input-var filename-prefix "" 'string)

(define-input-var epsilon-input-file "" 'string)

(define-input-var simple-preconditioner? false 'boolean)
(define-input-var deterministic? false 'boolean)
(define-input-var eigensolver-flags EIGS_DEFAULT_FLAGS 'integer)

(define-output-var freqs (make-list-type 'number))
(define-output-var z-parity (make-list-type 'number))
(define-output-var iterations 'integer)

; ****************************************************************

; Definitions of external (C) functions:

; (init-params p true) initializes the geometry, etcetera, and does
; everything else that's needed to get ready for an eigenvalue
; calculation with polarization p (see below).  This should be called
; after the input variables are changed.  If false is passed instead
; of true, fields from a previous run are retained, if possible, as a
; starting point for the eigensolver.
(define-external-function init-params true false
  no-return-value 'integer 'boolean)

; (set-polarization p) changes the polarization that is solved for by
; solve-kpoint, below.  p should be one of the following constants
; init-params should already have been called.  Be sure to call
; (randomize-fields) if you change the polarization without calling
; init-params.
(define NO-POLARIZATION 0)
(define TE 1)
(define TM 2)
(define EVEN-Z 3)
(define ODD-Z 4)
(define PREV-POLARIZATION -1)
(define-external-function set-polarization false false 
  no-return-value 'integer)

; (randomize-fields) initializes the fields to random values; should
; only be called after init-params.
(define-external-function randomize-fields false false no-return-value)

; (solve-kpoint kpoint) solves for the specified bands at the given k point.
; Requires that (init-params) has been called, and does not re-read the
; input variables, but does write the output vars.
(define-external-function solve-kpoint false true no-return-value 'vector3)

(define-external-function get-dfield false false no-return-value 'integer)
(define-external-function get-hfield false false no-return-value 'integer)
(define-external-function get-efield-from-dfield false false no-return-value)
(define-external-function get-epsilon false false no-return-value)
(define-external-function fix-field-phase false false no-return-value)
(define-external-function compute-field-energy false false 'number)
(define-external-function compute-energy-in-dielectric false false
  'number 'number 'number)
(define-external-function output-field-extended false false
  no-return-value 'vector3 'integer)  
(define-external-function compute-energy-in-object-list false false
  'number (make-list-type 'geometric-object))

; ****************************************************************

; Computing group velocities:

(define-external-function compute-group-velocity-component false false
  (make-list-type 'number) 'vector3)

; Return a list of the group velocity vector3's, in the cartesian
; basis (and units of c):
(define (compute-group-velocities)
  (let ((vx (compute-group-velocity-component
	     (cartesian->reciprocal (vector3 1 0 0))))
	(vy (compute-group-velocity-component
	     (cartesian->reciprocal (vector3 0 1 0))))
	(vz (compute-group-velocity-component
	     (cartesian->reciprocal (vector3 0 0 1)))))
    (map (lambda (x y z) (vector3 x y z)) vx vy vz)))

; Define a band function to be passed to run, so that you can easily
; display the group velocities for each k-point.  The band index b is
; only used to ensure that the output is printed just once (by only
; outputting for b=1):
(define (display-group-velocities b)
  (if (= b 1)
      (display-many "group velocities at " current-k ": "
		    (compute-group-velocities) "\n")))

; ****************************************************************

; Add some predefined variables, for convenience:

(define vacuum (make dielectric (epsilon 1.0)))
(define air vacuum)

(define infinity 1.0e20) ; big number for infinite dimensions of objects

(set! default-material air)

; ****************************************************************

; The remainder of this file consists of Scheme convenience functions.

; ****************************************************************

; Function to convert a k-point k into an equivalent point in the
; first Brillouin zone (not necessarily the irreducible Brillouin zone):
(define (first-brillouin-zone k)
  (define (n k) (vector3-norm (reciprocal->cartesian k)))
  (define (try+ k v)
    (if (< (n (vector3+ k v)) (n k)) (try+ (vector3+ k v) v) k))
  (define (try k v) (try+ (try+ k v) (vector3- (vector3 0) v)))
  (define (try-all k)
    (try (try (try k (vector3 1 0 0)) (vector3 0 1 0)) (vector3 0 0 1)))
  (define (try-all&repeat k)
    (let ((knew (try-all k)))
      (if (< (n knew) (n k)) (try-all&repeat knew) k)))
  (let ((k0 (vector3- k (vector-map inexact->exact k))))
    (if (< (n k0) (n k)) (try-all&repeat k0) (try-all&repeat k))))

; functions to manipulate the fields; these are mainly convenient
; wrappers for the external functions defined previously.

(define (get-efield which-band)
  (get-dfield which-band)
  (get-efield-from-dfield))

(define (output-field . copies)
  (output-field-extended (apply vector3 copies) -1))

(define (output-field-x . copies)
  (output-field-extended (apply vector3 copies) 0))

(define (output-field-y . copies)
  (output-field-extended (apply vector3 copies) 1))

(define (output-field-z . copies)
  (output-field-extended (apply vector3 copies) 2))

(define (output-epsilon . copies)
  (get-epsilon)
  (apply output-field copies))

(define (compute-energy-in-objects . objects)
  (compute-energy-in-object-list objects))

; ****************************************************************
; Functions to compute and output gaps, given the lists of frequencies
; computed at each k point.

; The band-range-data is a list if ((min . k-point) . (max . k-point))
; pairs, with each pair describing the frequency range of a band and
; the k-points where it achieves its maximum/minimum.  Here, we update
; this data with a new list of band frequencies, and return the new
; data.  If band-range-data is null or too short, the needed entries
; will be created.
(define (update-band-range-data band-range-data freqs k-point)
  (if (null? freqs)
      '()
      (let ((br (if (null? band-range-data)
		    (cons (cons infinity -1) (cons (- infinity) -1))
		    (car band-range-data)))
	    (br-rest (if (null? band-range-data) '() (cdr band-range-data))))
	(let ((newmin (if (< (car freqs) (caar br))
			  (cons (car freqs) k-point) (car br)))
	      (newmax (if (> (car freqs) (cadr br))
			  (cons (car freqs) k-point) (cdr br))))
	  (cons (cons newmin newmax)
		(update-band-range-data br-rest (cdr freqs) k-point))))))

; Output the band range data in a nice format:
(define (output-band-range-data br-data)
  (define (obr br i)
    (if (not (null? br))
	(begin
	  (display-many "Band " i " range: " (caaar br) " at " (cdaar br)
			" to "  (cadar br) " at " (cddar br) "\n")
	  (obr (cdr br) (+ i 1)))))
  (obr br-data 1))

; Output any gaps in the given band ranges, and return a list
; of the gaps as a list of (percent freq-min freq-max) lists.
(define (output-gaps band-range-data)
  (define (ogaps br-cur br-rest i)
    (if (null? br-rest)
	'()
	(if (>= (cadr br-cur) (caaar br-rest))
	    (ogaps (car br-rest) (cdr br-rest) (+ i 1))
	    (let ((gap-size (/ (* 200 (- (caaar br-rest) (cadr br-cur)))
			       (+ (caaar br-rest) (cadr br-cur)))))
	      (display-many "Gap from band " i " (" (cadr br-cur)
			    ") to band " (+ i 1) " (" (caaar br-rest) "), "
			    gap-size "%\n")
	      (cons (list gap-size (cadr br-cur) (caaar br-rest))
		    (ogaps (car br-rest) (cdr br-rest) (+ i 1)))))))
  (if (null? band-range-data)
      '()
      (ogaps (car band-range-data) (cdr band-range-data) 1)))

; variables holding the band range data and current list of gaps, in
; the format returned by update-band-range-data and output-gaps, above:
(define band-range-data '())
(define gap-list '())

; ****************************************************************

; stuff to keep statistics on the eigensolver performance, for tuning:
(define eigensolver-iters '()) ; the iterations used, updated by (run)

(define (display-eigensolver-stats)
  (let ((num-runs (length eigensolver-iters)))
    (if (> num-runs 0)
	(let ((min-iters (apply min eigensolver-iters))
	      (max-iters (apply max eigensolver-iters))
	      (mean-iters (/ (fold-right + 0 eigensolver-iters) num-runs)))
	  (display-many "eigensolver iterations for " num-runs 
			" k-points: " min-iters "-" max-iters
			", mean = "  mean-iters)
	  (if (defined? 'sort)  ; sort was added in Guile 1.3.x
	      (let ((sorted-iters (sort eigensolver-iters <)))
		(let ((median-iters (* 0.5 (+ (list-ref sorted-iters
							(quotient num-runs 2))
					      (list-ref sorted-iters
							(- (quotient 
							    (+ num-runs 1) 2)
							   1))))))
		  (display-many ", median = " median-iters))))
	  (newline)))))

; ****************************************************************

(define current-k (vector3 0)) ; current k point in the run function
(define all-freqs '()) ; list of all freqs computed in a run

; (run) functions, to do vanilla calculations.  They all take zero or
; more "band functions."  Each function should take a single
; parameter, the band index, and is called for each band index at
; every k point.  These are typically used to output the bands.

(define (run-polarization p reset-fields . band-functions)
  (begin-time "total elapsed time for run: "
   (set! all-freqs '())
   (set! band-range-data '())
   (set! interactive? false)  ; don't be interactive if we call (run)
   (begin-time "elapsed time for initialization: "
	       (init-params p reset-fields))
   (apply output-epsilon output-copies) ; output epsilon immediately
   (if (> num-bands 0)
       (begin
	 (map (lambda (k)
		(set! current-k k)
		(begin-time "elapsed time for k point: " (solve-kpoint k))
		(set! all-freqs (cons freqs all-freqs))
		(set! band-range-data 
		      (update-band-range-data band-range-data freqs k))
		(set! eigensolver-iters
		      (append eigensolver-iters (list iterations)))
		(map (lambda (f)
		       (do ((band 1 (+ band 1))) ((> band num-bands))
			 (f band)))
		     band-functions))
	      k-points)
	 (if (> (length k-points) 1)
	     (begin
	       (output-band-range-data band-range-data)
	       (set! gap-list (output-gaps band-range-data)))
	     (set! gap-list '())))))
  (set! all-freqs (reverse all-freqs)) ; put them in the right order
  (display "done.\n"))

(define (run . band-functions)
  (apply run-polarization
	 (append (list NO-POLARIZATION true) band-functions)))

(define (run-te . band-functions)
  (apply run-polarization (append (list TE true) band-functions)))

(define (run-tm . band-functions)
  (apply run-polarization (append (list TM true) band-functions)))

(define (run-even . band-functions)
  (apply run-polarization (append (list EVEN-Z true) band-functions)))

(define (run-odd . band-functions)
  (apply run-polarization (append (list ODD-Z true) band-functions)))

; ****************************************************************

; Some predefined output functions (functions of the band index),
; for passing to (run).

; a global for the number of copies these band functions output
(define-param output-copies '(1 1 1))

(define (output-hfield which-band)
  (get-hfield which-band)
  (apply output-field output-copies))
(define (output-hfield-x which-band)
  (get-hfield which-band)
  (apply output-field-x output-copies))
(define (output-hfield-y which-band)
  (get-hfield which-band)
  (apply output-field-y output-copies))
(define (output-hfield-z which-band)
  (get-hfield which-band)
  (apply output-field-z output-copies))

(define (output-dfield which-band)
  (get-dfield which-band)
  (apply output-field output-copies))
(define (output-dfield-x which-band)
  (get-dfield which-band)
  (apply output-field-x output-copies))
(define (output-dfield-y which-band)
  (get-dfield which-band)
  (apply output-field-y output-copies))
(define (output-dfield-z which-band)
  (get-dfield which-band)
  (apply output-field-z output-copies))

(define (output-efield which-band)
  (get-efield which-band)
  (apply output-field output-copies))
(define (output-efield-x which-band)
  (get-efield which-band)
  (apply output-field-x output-copies))
(define (output-efield-y which-band)
  (get-efield which-band)
  (apply output-field-y output-copies))
(define (output-efield-z which-band)
  (get-efield which-band)
  (apply output-field-z output-copies))

(define (output-hpwr which-band)
  (get-hfield which-band)
  (compute-field-energy)
  (apply output-field output-copies))

(define (output-dpwr which-band)
  (get-dfield which-band)
  (compute-field-energy)
  (apply output-field output-copies))

; The following function returns an output function that calls
; output-func for bands with D energy in objects > min-energy.
; For example, (output-dpwr-in-objects output-dfield 0.20 some-object)
; would return an output function that would spit out the D field
; for bands with at least %20 of their D energy in some-object.
(define (output-dpwr-in-objects output-func min-energy . objects)
  (lambda (which-band)
    (get-dfield which-band)
    (compute-field-energy)
    (let ((energy (compute-energy-in-object-list objects)))
        ; output the computed energy for grepping:
	(display-many "dpwr:, " which-band ", "
		      (list-ref freqs (- which-band 1)) ", " energy "\n")
	(if (>= energy min-energy)
	    (output-func which-band)))))

; Combines zero or more band functions into one:
(define (combine-band-functions . band-funcs)
  (lambda (which-band)
    (map (lambda (f) (f which-band)) band-funcs)))

; Only invoke the given band functions for the specified k-point:
(define (output-at-kpoint kpoint . band-funcs)
  (let ((band-func (apply combine-band-functions band-funcs)))
    (lambda (which-band)
      (if (vector3= current-k kpoint)
	  (band-func which-band)))))

; Band functions to pick a canonical phase for the eigenstate of the
; given band based upon the spatial representation of the given field:
(define (fix-hfield-phase which-band)
  (get-hfield which-band)
  (fix-field-phase))
(define (fix-dfield-phase which-band)
  (get-dfield which-band)
  (fix-field-phase))
(define (fix-efield-phase which-band)
  (get-efield which-band)
  (fix-field-phase))

; ****************************************************************

; Load GNU Readline support, for easier command-line editing support.
; This is not loaded in by default in Guile 1.3.2+ because readline
; is licensed under the GPL, which would have caused Guile to effectively
; be under the GPL itself.  However, since the MIT Photonic Bands package
; is under the GPL too, we can load Readline by default with no problems.

@ACTIVATE_READLINE@  ; command to activate readline is determined by configure

; ****************************************************************
